{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/./node_modules/denque/index.js","webpack://[name]/./node_modules/heap/index.js","webpack://[name]/./node_modules/heap/lib/heap.js","webpack://[name]/./src/PathFinding/algorithms/AStar.js","webpack://[name]/./src/PathFinding/algorithms/BestFirstSearch.js","webpack://[name]/./src/PathFinding/algorithms/BreadthFirstSearch.js","webpack://[name]/./src/PathFinding/algorithms/Dijkshtra.js","webpack://[name]/./src/PathFinding/algorithms/IDAStar.js","webpack://[name]/./src/PathFinding/algorithms/IDDFS.js","webpack://[name]/./src/PathFinding/algorithms/JumpPointSearch.js","webpack://[name]/./src/PathFinding/algorithms/MultiAStar.js","webpack://[name]/./src/PathFinding/algorithms/MultiBFS.js","webpack://[name]/./src/PathFinding/algorithms/MultiBestFirstSearch.js","webpack://[name]/./src/PathFinding/algorithms/MultiDijkshtra.js","webpack://[name]/./src/PathFinding/core/GraphNode.js","webpack://[name]/./src/PathFinding/core/Grid.js","webpack://[name]/./src/PathFinding/core/MultiEPGrid.js","webpack://[name]/./src/PathFinding/index.js","webpack://[name]/./src/PathFinding/utils/BackTrace.js","webpack://[name]/./src/PathFinding/utils/Heuristics.js"],"names":["AStar","options","console","log","allowDiagonal","biDirectional","doNotCrossCornersBetweenObstacles","markCurrentProcessingNode","heuristic","heuristics","findPath","findBiPath","currentProcessingNode","neighbour","Math","abs","x","y","SQRT2","grid","minHeap","Heap","node1","node2","f","startNode","getNodeAtXY","startPoint","endNode","endPoint","neighbours","neighbourGVal","g","insert","addedToHeap","empty","pop","currentNode","backTrace","getNeighbours","forEach","visited","getDistanceFromCurrentProcessignNode","h","parent","updateItem","minHeapFromStart","minHeapFromEnd","by","length","shift","biBackTrace","BestFirstSearch","heuristicToOverride","BreadthFirstSearch","queue","Denque","addedToQueue","isEmpty","push","startNeighbours","endNeighbours","startQueue","endQueue","Dijkshtra","Array","prototype","peekTop","undefined","IDAStar","timeLimit","rootNode","startTime","Date","uppperBound","returnedInstance","path","search","info","rootGVal","upperBound","timeUp","fVal","explored","min","Infinity","includes","getDistanceFromRootNode","IDDFS","JumpPointSearch","max","parentX","parentY","xNormalizeDirection","yNormalizeDirection","isXYWallElement","xDifference","yDifference","processed","getJumpPoints","columns","rows","jumpPointNode","jumpPointDistanceFromStart","getNeighboursBasedOnOptions","jumpPoints","expandPath","successor","MultiAStar","multiEPGrid","endNodesList","multiEPGridPass","closestEndNode","subPath","i","endPoints","sort","clone","finder","removeEndPoint","k","splice","concat","isXYEndPoint","MultiBFS","currentIterationID","backTraceInIteration","clear","node","iterationID","MultiBestFirstSearch","MultiDijkshtra","GraphNode","Grid","isWall","makeXYWall","a","b","c","d","MultiEPGrid","some","ep","from","to","findIndex","filter","BackTrace","reverse","inIteration","path1","path2","firstNode","secondNode","x1","y1","x2","y2","xDirection","yDirection","interpolatedValues","intermidateDistance","expandedPath","getInterpolation","sqrt","Heuristic","nodeA","nodeB","weight","dx","dy"],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,GAAG;AACH,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,eAAe,gBAAgB;AAC/B,GAAG;AACH,wBAAwB,gBAAgB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACpbA,iBAAiB,mBAAO,CAAC,mDAAY;;;;;;;;;;;;ACArC;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mCAAmC,0BAA0B,oBAAoB;AACvI;AACA,KAAK;AACL;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC;AACxF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA,QAAQ,IAA0C;AAClD,aAAa,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAChC,KAAK,MAAM,EAIN;AACL,GAAG;AACH;AACA,GAAG;;AAEH,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACtXD;AACA;AACA;;IAEqBA,K;AACpB,iBAAYC,OAAZ,EAAoB;AAAA;;AACnBC,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","file":"PathFinder.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/PathFinding/index.js\");\n","'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array) {\n  this._head = 0;\n  this._tail = 0;\n  this._capacityMask = 0x3;\n  this._list = new Array(4);\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  }\n}\n\n/**\n * -------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peakAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (item === undefined) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (item === undefined) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = ( i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  for (var i = 0; i < array.length; i++) this.push(array[i]);\n};\n\n/**\n *\n * @param fullCopy\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy) {\n  var newArray = [];\n  var list = this._list;\n  var len = list.length;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < len; i++) newArray.push(list[i]);\n    for (i = 0; i < this._tail; i++) newArray.push(list[i]);\n  } else {\n    for (i = this._head; i < this._tail; i++) newArray.push(list[i]);\n  }\n  return newArray;\n};\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head) {\n    // copy existing data, head to end, then beginning to tail.\n    this._list = this._copyArray(true);\n    this._head = 0;\n  }\n\n  // head is at 0 and array is now full, safe to extend\n  this._tail = this._list.length;\n\n  this._list.length *= 2;\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n\nmodule.exports = Denque;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","import Heap from 'heap';\nimport backTrace from '../utils/BackTrace';\nimport heuristics from '../utils/Heuristics';\n\nexport default class AStar{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t\tif(this.biDirectional){\n\t\t\tthis.findPath = this.findBiPath;\n\t\t}\n\t}\n\n\tgetDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour){\n\t\tif((Math.abs(currentProcessingNode.x-neighbour.x)+Math.abs(currentProcessingNode.y-neighbour.y))===1){\n\t\t\treturn 1;\n\t\t}\n\t\treturn Math.SQRT2;\n\t}\n\n\tfindPath(grid){\n\t\tlet minHeap = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tstartNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y),\n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tneighbourGVal;\n\n\t\tstartNode.f = 0;\n\t\tstartNode.g = 0;\n\t\tendNode.f = 0;\n\t\tendNode.g = 0;\n\n\t\tminHeap.insert(startNode);\n\t\tstartNode.addedToHeap = true;\n\n\t\twhile(!minHeap.empty()){\n\t\t\tcurrentProcessingNode = minHeap.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\n\t\t\tif(currentProcessingNode === endNode){\n\t\t\t\treturn backTrace.backTrace(currentProcessingNode, startNode);\n\t\t\t}\n\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited) return; //equivalent to continue in forEach\n\n\t\t\t\tneighbourGVal = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\n\t\t\t\t} else if(neighbour.g > neighbourGVal){\n\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.updateItem(neighbour);\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tfindBiPath(grid){\n\t\tlet minHeapFromStart = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tminHeapFromEnd = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tstartNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y),\n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tneighbour,\n\t\t\tneighbourGVal;\n\n\t\tstartNode.f = 0;\n\t\tstartNode.g = 0;\n\t\tendNode.f = 0;\n\t\tendNode.g = 0;\n\n\t\tminHeapFromStart.insert(startNode);\n\t\tstartNode.addedToHeap = true;\n\t\tstartNode.by = 'start';\n\t\tminHeapFromEnd.insert(endNode);\n\t\tendNode.addedToHeap = true;\n\t\tendNode.by = 'end';\n\n\t\twhile(!minHeapFromStart.empty() && !minHeapFromEnd.empty()){\n\n\t\t\tcurrentProcessingNode = minHeapFromStart.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(neighbours.length){\n\t\t\t\tneighbour = neighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tneighbourGVal = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeapFromStart.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\tneighbour.by = 'start';\n\n\t\t\t\t} else {\n\t\t\t\t\tif(neighbour.by === 'end'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(currentProcessingNode, startNode, neighbour, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tif(neighbour.g > neighbourGVal){\n\t\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\t\tminHeapFromStart.updateItem(neighbour);\n\t\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\t\tneighbour.by = 'start';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentProcessingNode.visited = true;\n\n\t\t\tcurrentProcessingNode = minHeapFromEnd.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(neighbours.length){\n\t\t\t\tneighbour = neighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tneighbourGVal = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\tneighbour.h = this.heuristic(startNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeapFromEnd.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\tneighbour.by = 'end';\n\n\t\t\t\t} else {\n\t\t\t\t\tif(neighbour.by === 'start'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(neighbour, startNode, currentProcessingNode, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tif(neighbour.g > neighbourGVal){\n\t\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\t\tneighbour.h = this.heuristic(startNode, neighbour);\n\t\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\t\tminHeapFromEnd.updateItem(neighbour);\n\t\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\t\tneighbour.by = 'end';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t}\n}\n","import AStar from './AStar';\n\nexport default class BestFirstSearch extends AStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tlet heuristicToOverride = this.heuristic;\n\n\t\tthis.heuristic = (node1, node2) => {\n\t\t\treturn heuristicToOverride(node1, node2, 500000);\n\t\t};\n\t}\n}\n","import Denque from 'denque';\nimport backTrace from '../utils/BackTrace';\n\nexport default class BreadthFirstSearch{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t\tif(this.biDirectional){\n\t\t\tthis.findPath = this.findBiPath;\n\t\t}\n\t}\n\n\tfindPath(grid){\n\t\tlet startPoint = grid.startPoint,\n\t\t\tendPoint = grid.endPoint,\n\t\t\tstartNode = grid[startPoint.y][startPoint.x],\n\t\t\tendNode = grid[endPoint.y][endPoint.x];\n\n\t\tlet queue = new Denque([startNode]),\n\t\t\tneighbours = [],\n\t\t\tcurrentProcessingNode;\n\n\t\tstartNode.addedToQueue = true;\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tcurrentProcessingNode = queue.shift(); // Dequeue operation on queue\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\n\t\t\tif(currentProcessingNode === endNode){\n\t\t\t\treturn backTrace.backTrace(endNode, startNode);\n\t\t\t}\n\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited || neighbour.addedToQueue){\n\t\t\t\t\treturn; // equivalent to CONTINUE in forEach\n\t\t\t\t}\n\t\t\t\tqueue.push(neighbour);\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tfindBiPath(grid){\n\t\tlet startNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y),\n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y),\n\t\t\tneighbour,\n\t\t\tcurrentProcessingNode,\n\t\t\tstartNeighbours = [],\n\t\t\tendNeighbours = [];\n\n\t\tlet startQueue = new Denque([startNode]),\n\t\t\tendQueue = new Denque([endNode]);\n\n\t\tstartNode.addedToQueue = true;\n\t\tendNode.addedToQueue = true;\n\t\tstartNode.by = 'start';\n\t\tendNode.by = 'end';\n\n\t\twhile(!startQueue.isEmpty() && !endQueue.isEmpty()){\n\t\t\tcurrentProcessingNode = startQueue.shift();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tstartNeighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(startNeighbours.length){\n\t\t\t\tneighbour = startNeighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(neighbour.addedToQueue){\n\t\t\t\t\tif(neighbour.by === 'end'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(currentProcessingNode, startNode, neighbour, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstartQueue.push(neighbour);\n\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\tneighbour.by = 'start';\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t}\n\n\t\t\tcurrentProcessingNode.visited = true;\n\n\t\t\tcurrentProcessingNode = endQueue.shift();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tendNeighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(endNeighbours.length){\n\t\t\t\tneighbour = endNeighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(neighbour.addedToQueue){\n\t\t\t\t\tif(neighbour.by === 'start'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(neighbour, startNode, currentProcessingNode, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendQueue.push(neighbour);\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t\tneighbour.parent=currentProcessingNode;\n\t\t\t\tneighbour.by='end';\n\t\t\t}\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\t\treturn [];\n\t}\n}\n\n","import AStar from './AStar';\n\nexport default class Dijkshtra extends AStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.heuristic = () => {\n\t\t\treturn 0;\n\t\t};\n\t}\n}\n","import heuristics from '../utils/Heuristics';\n\nArray.prototype.peekTop = function(){\n\treturn this.length?this[this.length-1]:undefined;\n};\n\nexport default class IDAStar{\n\tconstructor(options){\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t\t// this.heuristic = heuristics[\"euclidean\"];\n\t\tthis.timeLimit = 100;\n\t}\n\n\tgetDistanceFromRootNode(rootNode, neighbour){\n\t\tif((Math.abs(rootNode.x-neighbour.x)+Math.abs(rootNode.y-neighbour.y))===1){\n\t\t\treturn 1;\n\t\t}\n\t\treturn Math.SQRT2;\n\t}\n\n\ttimeUp(){\n\t\treturn (Math.abs(this.startTime - new Date())>this.timeLimit);\n\t}\n\n\tfindPath(grid){\n\t\tthis.grid = grid;\n\t\tlet uppperBound = this.heuristic(grid.startPoint, grid.endPoint),\n\t\t\treturnedInstance;\n\n\t\tgrid.startNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y);\n\t\tgrid.endNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y);\n\n\t\tthis.startTime = new Date();\n\t\tlet path = [ grid.startNode ];\n\n\t\twhile(true){\n\t\t\treturnedInstance = this.search(path, 0, uppperBound);\n\n\t\t\tif(typeof(returnedInstance) === \"number\"){\n\t\t\t\tconsole.info(\"bound Increased to\", returnedInstance);\n\t\t\t\tuppperBound = returnedInstance;\n\t\t\t} else if(returnedInstance === \"FOUND\"){\n\t\t\t\treturn path;\n\t\t\t} else {\n\t\t\t\treturn returnedInstance;\n\t\t\t}\n\t\t}\n\t}\n\n\tsearch(path, rootGVal, upperBound){\n\t\tlet rootNode = path.peekTop();\n\t\tif(this.timeUp()) {\n\t\t\tconsole.info(\"time exceeded\");\n\t\t\treturn [];\n\t\t}\n\n\t\tif(rootNode === this.grid.endNode){\n\t\t\tconsole.info(\"found\");\n\t\t\treturn \"FOUND\";\n\t\t}\n\n\t\tlet fVal = rootGVal + this.heuristic(rootNode, this.grid.endNode);\n\t\tif(fVal > upperBound) {\n\t\t\trootNode.explored = true;\n\t\t\treturn fVal;\n\t\t}\n\n\t\tif(this.markCurrentProcessingNode) rootNode.currentNode = true;\n\t\trootNode.visited = true;\n\n\t\tlet min = Infinity,\n\t\t\tneighbourGVal,\n\t\t\treturnedInstance,\n\t\t\tneighbour,\n\t\t\tneighbours = this.grid.getNeighbours(rootNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\twhile(neighbours.length){\n\t\t\tneighbour = neighbours.shift();\n\t\t\tif(!path.includes(neighbour)){\n\t\t\t\tpath.push(neighbour);\n\t\t\t\tneighbourGVal = rootGVal+this.getDistanceFromRootNode(rootNode, neighbour);\n\n\t\t\t\treturnedInstance = this.search(path, neighbourGVal, upperBound);\n\n\t\t\t\tif((typeof(returnedInstance) === \"number\") && (returnedInstance < min)){\n\t\t\t\t\tmin = returnedInstance;\n\t\t\t\t} else if(returnedInstance === \"FOUND\"){\n\t\t\t\t\treturn returnedInstance;\n\t\t\t\t}\n\t\t\t\tpath.pop(neighbour);\n\t\t\t}\n\t\t}\n\n\t\trootNode.visited = false;\n\t\treturn min;\n\t}\n}\n","import IDAStar from './IDAStar';\n\nexport default class IDDFS extends IDAStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.heuristic = () => 0;\n\t}\n}\n","import Heap from 'heap';\nimport backTrace from '../utils/BackTrace';\nimport heuristics from '../utils/Heuristics';\n\nexport default class JumpPointSearch{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t}\n\n\tgetNeighboursBasedOnOptions(currentProcessingNode){\n\t\tlet parent = currentProcessingNode.parent,\n\t\t\tabs = Math.abs,\n\t\t\tmax = Math.max,\n\t\t\tparentX,\n\t\t\tparentY,\n\t\t\txNormalizeDirection,\n\t\t\tyNormalizeDirection,\n\t\t\tx = currentProcessingNode.x,\n\t\t\ty = currentProcessingNode.y,\n\t\t\tneighbours = [];\n\t\tif (parent){\n\t\t\tparentX = parent.x;\n\t\t\tparentY = parent.y;\n\t\t\txNormalizeDirection = (x -parentX)/(max(abs(x -parentX), 1));\n\t\t\tyNormalizeDirection = (y -parentY)/(max(abs(y - parent.y), 1));\n\n\t\t\tif (xNormalizeDirection !== 0){\n\t\t\t\tif (!this.grid.isXYWallElement(x, y-1)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x, y-1));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x, y+1)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x, y+1));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x+xNormalizeDirection, y)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x+xNormalizeDirection, y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (yNormalizeDirection !== 0){\n\t\t\t\tif (!this.grid.isXYWallElement(x-1, y)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x-1, y));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x+1, y)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x+1, y));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x, y+yNormalizeDirection)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x, y+yNormalizeDirection));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tneighbours = this.grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\t\t}\n\t\treturn neighbours;\n\t}\n\n\tgetJumpPoints(currentProcessingNode, parent){\n\t\tlet x = currentProcessingNode.x,\n\t\t\ty = currentProcessingNode.y,\n\t\t\tparentX = parent.x,\n\t\t\tparentY = parent.y,\n\t\t\txDifference = currentProcessingNode.x - parent.x,\n\t\t\tyDifference = currentProcessingNode.y - parent.y;\n\t\tif (this.grid.isXYWallElement(x, y)){\n\t\t\treturn null;\n\t\t}\n\t\tif(this.markCurrentProcessingNode) currentProcessingNode.processed = true;\n\n\t\tif (currentProcessingNode === this.grid.endNode){\n\t\t\treturn currentProcessingNode;\n\t\t}\n\n\t\tif (xDifference !== 0){\n\t\t\tif ((!this.grid.isXYWallElement(x, y-1) && this.grid.isXYWallElement(parentX, y-1)) || (!this.grid.isXYWallElement(x, y+1) && this.grid.isXYWallElement(parentX, y+1))){\n\t\t\t\treturn currentProcessingNode;\n\t\t\t}\n\t\t} else if (yDifference !== 0){\n\t\t\tif ((!this.grid.isXYWallElement(x-1, y) && this.grid.isXYWallElement(x-1, parentY)) || (!this.grid.isXYWallElement(x+1, y) && this.grid.isXYWallElement(x+1, parentY))){\n\t\t\t\treturn currentProcessingNode;\n\t\t\t}\n\t\t\tif (this.getJumpPoints(this.grid.getNodeAtXY(x+1, y), currentProcessingNode) || this.getJumpPoints(this.grid.getNodeAtXY(x-1, y), currentProcessingNode)){\n\t\t\t\treturn currentProcessingNode;\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('only vertical and horizontal movements allowed');\n\t\t}\n\n\t\tif (x+xDifference>=0 && x+xDifference<this.grid.columns && y+yDifference>=0 && y+yDifference<this.grid.rows){\n\t\t\treturn this.getJumpPoints(this.grid.getNodeAtXY(x+xDifference, y+yDifference), currentProcessingNode);\n\t\t}\n\t}\n\n\tsuccessor(currentProcessingNode){\n\n\t\tlet neighbours = [],\n\t\t\tjumpPointNode,\n\t\t\tneighbour,\n\t\t\tjumpPointDistanceFromStart;\n\t\tneighbours = this.getNeighboursBasedOnOptions(currentProcessingNode);\n\n\t\twhile(neighbours.length){\n\t\t\tneighbour = neighbours.shift();\n\t\t\tjumpPointNode = this.getJumpPoints(neighbour, currentProcessingNode);\n\t\t\tif (jumpPointNode){\n\t\t\t\tif (jumpPointNode.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjumpPointDistanceFromStart = currentProcessingNode.g + heuristics['octile'](jumpPointNode, currentProcessingNode);\n\t\t\t\tif(!jumpPointNode.addedToHeap || jumpPointDistanceFromStart<jumpPointNode.g){\n\t\t\t\t\tjumpPointNode.g = jumpPointDistanceFromStart;\n\t\t\t\t\tjumpPointNode.h = this.heuristic(this.grid.endNode, jumpPointNode);\n\t\t\t\t\tjumpPointNode.f = jumpPointNode.g+jumpPointNode.h;\n\t\t\t\t\tjumpPointNode.parent = currentProcessingNode;\n\n\t\t\t\t\tif (!jumpPointNode.addedToHeap){\n\t\t\t\t\t\tthis.minHeap.insert(jumpPointNode);\n\t\t\t\t\t\tjumpPointNode.addedToHeap = true;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tthis.minHeap.updateItem(jumpPointNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfindPath(grid){\n\t\tthis.grid = grid;\n\t\tlet minHeap = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tcurrentProcessingNode;\n\t\tthis.minHeap = minHeap;\n\n\t\tthis.grid.startNode = this.grid.getNodeAtXY(this.grid.startPoint.x, this.grid.startPoint.y);\n\t\tthis.grid.endNode = this.grid.getNodeAtXY(this.grid.endPoint.x, this.grid.endPoint.y);\n\t\tthis.grid.startNode.g = 0;\n\t\tthis.grid.startNode.f = 0;\n\t\tthis.minHeap.insert(this.grid.startNode);\n\t\tthis.grid.startNode.addedToHeap = true;\n\n\t\twhile(!this.minHeap.empty()){\n\n\t\t\tcurrentProcessingNode = this.minHeap.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.processed = true;\n\t\t\tcurrentProcessingNode.visited = true;\n\n\t\t\tif (currentProcessingNode === this.grid.endNode){\n\t\t\t\tlet jumpPoints = backTrace.backTrace(this.grid.endNode, this.grid.startNode);\n\t\t\t\tlet path = backTrace.expandPath(this.grid, jumpPoints, this.grid.startNode);\n\t\t\t\tconsole.log(path);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tthis.successor(currentProcessingNode);\n\t\t}\n\t\treturn [];\n\t}\n}\n","import Heap from 'heap';\nimport backTrace from '../utils/BackTrace';\nimport heuristics from '../utils/Heuristics';\n\nexport default class MultiAStar{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t}\n\n\tgetDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour){\n\t\tif((Math.abs(currentProcessingNode.x-neighbour.x)+Math.abs(currentProcessingNode.y-neighbour.y))===1){\n\t\t\treturn 1;\n\t\t}\n\t\treturn Math.SQRT2;\n\t}\n\n\tfindPath(multiEPGrid){\n\t\tlet endNodesList = [],\n\t\t\tmultiEPGridPass,\n\t\t\tstartNode = multiEPGrid.getNodeAtXY(multiEPGrid.startPoint.x, multiEPGrid.startPoint.y),\n\t\t\tendPoint,\n\t\t\tendNode,\n\t\t\tclosestEndNode,\n\t\t\tpath = [],\n\t\t\tsubPath = [];\n\n\t\t// console.log(startNode);\n\t\t// console.log(multiEPGrid.endPoints);\n\n\t\tfor(let i=0;i<multiEPGrid.endPoints.length;i++){\n\t\t\tendPoint = multiEPGrid.endPoints[i];\n\t\t\tendNode = multiEPGrid.getNodeAtXY(endPoint.x, endPoint.y);\n\t\t\tendNodesList.push(endNode);\n\t\t\tendNode.h = heuristics['euclidean'](endNode, startNode);\n\n\t\t}\n\t\tendNodesList.sort(function(node1, node2){\n\t\t\treturn node1.h - node2.h;\n\t\t});\n\n\t\twhile(endNodesList.length){\n\n\t\t\tmultiEPGridPass = multiEPGrid.clone();\n\t\t\tclosestEndNode = endNodesList.shift();\n\t\t\tsubPath = this.finder(startNode, closestEndNode, multiEPGridPass);\n\t\t\t// console.log(subPath);\n\n\t\t\tif (subPath.length){\n\t\t\t\tif ((subPath[subPath.length -1].x === closestEndNode.x) && (subPath[subPath.length -1].y === closestEndNode.y)){\n\t\t\t\t\tmultiEPGrid.removeEndPoint(closestEndNode);\n\t\t\t\t}else{\n\t\t\t\t\tendNodesList.push(closestEndNode);\n\t\t\t\t\tmultiEPGrid.removeEndPoint(subPath[subPath.length -1]);\n\t\t\t\t\tfor (let k=0;k<endNodesList.length;k++){\n\t\t\t\t\t\tendNode = endNodesList[k];\n\t\t\t\t\t\tif ((endNode.x === subPath[subPath.length -1].x) && (endNode.y === subPath[subPath.length -1].y)){\n\t\t\t\t\t\t\tendNodesList.splice(k, 1);\n\t\t\t\t\t\t\t// console.log(endNodesList);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpath = path.concat(subPath);\n\t\t\t\tstartNode = subPath[subPath.length -1];\n\t\t\t}\n\n\t\t\tfor (let i=0;i<endNodesList.length;i++){\n\t\t\t\tendNode = endNodesList[i];\n\t\t\t\tendNode.h = heuristics['euclidean'](endNode, startNode);\n\t\t\t}\n\t\t\tendNodesList.sort(function(node1, node2){\n\t\t\t\treturn node1.h - node2.h;\n\t\t\t});\n\t\t}\n\t\treturn path;\n\t}\n\n\tfinder(startNode, endNode, multiEPGrid){\n\t\tlet minHeap = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tneighbourGVal;\n\n\t\tstartNode.f = 0;\n\t\tstartNode.g = 0;\n\t\tendNode.f = 0;\n\t\tendNode.g = 0;\n\n\t\tminHeap.insert(startNode);\n\t\tstartNode.addedToHeap = true;\n\n\t\twhile(!minHeap.empty()){\n\t\t\tcurrentProcessingNode = minHeap.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tif (multiEPGrid.isXYEndPoint(currentProcessingNode.x, currentProcessingNode.y)){\n\t\t\t\treturn backTrace.backTrace(currentProcessingNode, startNode);\n\t\t\t}\n\t\t\tneighbours = multiEPGrid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited) return; //equivalent to continue in forEach\n\n\t\t\t\tneighbourGVal = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\n\t\t\t\t} else if(neighbour.g > neighbourGVal){\n\t\t\t\t\tneighbour.g = neighbourGVal;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.updateItem(neighbour);\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n\n}\n","import Denque from 'denque';\nimport backTrace from '../utils/BackTrace';\n\nexport default class MultiBFS{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t}\n\n\tfindPath(multiEPGrid){\n\t\tlet startPoint = multiEPGrid.startPoint,\n\t\t\tstartNode = multiEPGrid.getNodeAtXY(startPoint.x, startPoint.y),\n\t\t\tqueue = new Denque([startNode]),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tpath = [],\n\t\t\tcurrentIterationID = 1;\n\n\t\tstartNode.addedToQueue = true;\n\t\twhile(!queue.isEmpty()){\n\t\t\tcurrentProcessingNode = queue.shift();\n\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\n\t\t\tif(multiEPGrid.isXYEndPoint(currentProcessingNode.x, currentProcessingNode.y)){\n\t\t\t\tpath = path.concat(backTrace.backTraceInIteration(currentIterationID, currentProcessingNode, startNode));\n\t\t\t\tstartNode = currentProcessingNode;\n\t\t\t\tmultiEPGrid.removeEndPoint(currentProcessingNode);\n\t\t\t\t// console.log(path, multiEPGrid.endPoints);\n\t\t\t\tqueue.clear();\n\t\t\t\tcurrentIterationID++;\n\t\t\t\tif(!multiEPGrid.endPoints.length) return path;\n\t\t\t}\n\n\t\t\tneighbours = multiEPGrid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.addedToQueue === currentIterationID || neighbour.visited === currentIterationID) return;\n\n\t\t\t\tneighbour.addedToQueue = currentIterationID;\n\t\t\t\tqueue.push(neighbour);\n\t\t\t\tneighbour.parent = {\n\t\t\t\t\tnode: currentProcessingNode,\n\t\t\t\t\titerationID: currentIterationID\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = currentIterationID;\n\t\t}\n\n\t\treturn path;\n\t}\n}\n","import MultiAStar from './MultiAStar';\n\nexport default class MultiBestFirstSearch extends MultiAStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tlet heuristicToOverride = this.heuristic;\n\n\t\tthis.heuristic = (node1, node2) => {\n\t\t\treturn heuristicToOverride(node1, node2, 500000);\n\t\t};\n\t}\n}\n","import MultiAStar from './MultiAStar';\n\nexport default class MultiDijkshtra extends MultiAStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.heuristic = () => {\n\t\t\treturn 0;\n\t\t};\n\t}\n}\n","class GraphNode{\n\tconstructor(options){\n\t\tthis.x = options.x;\n\t\tthis.y = options.y;\n\t}\n}\n\nexport default GraphNode;\n","import GraphNode from './GraphNode';\n\nclass Grid{\n\tconstructor(options){\n\t\tthis.rows = options.rows;\n\t\tthis.columns = options.columns;\n\t\tthis.startPoint = options.startPoint;\n\t\tthis.endPoint = options.endPoint;\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tthis[y] = new Array(this.columns);\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tthis[y][x] = new GraphNode({x, y});\n\t\t\t}\n\t\t}\n\t}\n\n\tisXYWallElement(x, y){\n\t\tif(x<0 || x>=this.columns || y<0 || y>=this.rows) return true;\n\t\treturn (this[y][x].isWall?true:false);\n\t}\n\n\tmakeXYWall(x, y){\n\t\tthis[y][x].isWall = true;\n\t}\n\n\tdestroyWallAtXY(x, y){\n\t\tthis[y][x].isWall = false;\n\t}\n\n\tisXYStartPoint(x, y){\n\t\treturn ((this.startPoint.x === x )&&(this.startPoint.y === y));\n\t}\n\n\tisXYEndPoint(x, y){\n\t\treturn ((this.endPoint.x === x )&&(this.endPoint.y === y));\n\t}\n\n\tgetNodeAtXY(x, y){\n\t\treturn this[y][x];\n\t}\n\n\tclone(){\n\t\tlet grid = new Grid(this);\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tif(this.isXYWallElement(x, y)) grid.makeXYWall(x, y);\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\n\t/*\n\t\t|_ _|_a_|_ _| |_p_|_ _|_q_| \n\t\t|_d_|_*_|_b_| |_ _|_*_|_ _|\n\t\t|_ _|_c_|_ _| |_s_|_ _|_r_|\n\t */\n\tgetNeighbours(node, allowDiagonal, doNotCrossCornersBetweenObstacles){\n\t\tlet neighbours = [];\n\t\tconst {x, y} = node;\n\t\tlet a, b, c, d;\n\n\t\t// b\n\t\tif(!this.isXYWallElement(x+1, y)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x+1, y));\n\t\t\tb = true;\n\t\t}\n\t\t// c\n\t\tif(!this.isXYWallElement(x, y+1)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x, y+1));\n\t\t\tc = true;\n\t\t}\n\t\t// d\n\t\tif(!this.isXYWallElement(x-1, y)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x-1, y));\n\t\t\td = true;\n\t\t}\n\t\t// a\n\t\tif(!this.isXYWallElement(x, y-1)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x, y-1));\n\t\t\ta = true;\n\t\t}\n\n\t\tif(allowDiagonal){\n\t\t\tif(doNotCrossCornersBetweenObstacles){\n\t\t\t\t//p\n\t\t\t\tif( (a || d) & !this.isXYWallElement(x-1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y-1));\n\t\t\t\t}\n\t\t\t\t//q\n\t\t\t\tif( (a || b) & !this.isXYWallElement(x+1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y-1));\n\t\t\t\t}\n\t\t\t\t//r\n\t\t\t\tif( (b || c) & !this.isXYWallElement(x+1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y+1));\n\t\t\t\t}\n\t\t\t\t//s\n\t\t\t\tif( (c || d) & !this.isXYWallElement(x-1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y+1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//p\n\t\t\t\tif(!this.isXYWallElement(x-1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y-1));\n\t\t\t\t}\n\t\t\t\t//q\n\t\t\t\tif(!this.isXYWallElement(x+1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y-1));\n\t\t\t\t}\n\t\t\t\t//r\n\t\t\t\tif(!this.isXYWallElement(x+1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y+1));\n\t\t\t\t}\n\t\t\t\t//s\n\t\t\t\tif(!this.isXYWallElement(x-1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn neighbours;\n\t}\n}\n\nexport default Grid;\n","import Grid from './Grid';\n\nclass MultiEPGrid extends Grid{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.endPoints = options.endPoints;\n\t}\n\n\tisXYEndPoint(x, y){\n\t\treturn (this.endPoints.some(ep => (ep.x===x)&&(ep.y===y)));\n\t}\n\n\tshiftEndPoint(from, to){\n\t\tlet i = this.endPoints.findIndex(ep => (ep.x===from.x)&&(ep.y===from.y));\n\t\tif(i!=-1){\n\t\t\tthis.endPoints[i] = to;\n\t\t}\n\t}\n\n\tremoveEndPoint(node){\n\t\tthis.endPoints = this.endPoints.filter(ep => !((ep.x===node.x)&&(ep.y===node.y)));\n\t}\n\n\tclone(){\n\t\tlet grid = new MultiEPGrid(this);\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tif(this.isXYWallElement(x, y)) grid.makeXYWall(x, y);\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n}\n\nexport default MultiEPGrid;\n","// Core\nimport Grid from './core/Grid';\nimport MultiEPGrid from './core/MultiEPGrid';\nimport GraphNode from './core/GraphNode';\n\n// Single EndPoint\nimport BreadthFirstSearch from './algorithms/BreadthFirstSearch';\nimport AStar from './algorithms/AStar';\nimport Dijkshtra from './algorithms/Dijkshtra';\nimport BestFirstSearch from './algorithms/BestFirstSearch';\nimport IDAStar from './algorithms/IDAStar';\nimport IDDFS from './algorithms/IDDFS';\nimport JumpPointSearch from './algorithms/JumpPointSearch';\n\n// Multi EndPoints\nimport MultiBFS from './algorithms/MultiBFS';\nimport MultiAStar from './algorithms/MultiAStar';\nimport MultiBestFirstSearch from './algorithms/MultiBestFirstSearch';\nimport MultiDijkshtra from './algorithms/MultiDijkshtra';\n\nexport default {\n\tGrid,\n\tMultiEPGrid,\n\tGraphNode,\n\n\tBreadthFirstSearch,\n\tAStar,\n\tDijkshtra,\n\tBestFirstSearch,\n\tIDAStar,\n\tIDDFS,\n\tJumpPointSearch,\n\n\tMultiBFS,\n\tMultiAStar,\n\tMultiBestFirstSearch,\n\tMultiDijkshtra\n};\n","class BackTrace{\n\tbackTrace(node, startNode){\n\t\tlet path = [];\n\t\twhile(node !== startNode){\n\t\t\tpath.push(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\tpath.reverse();\n\t\treturn path;\n\t}\n\n\tbackTraceInIteration(inIteration, node, startNode){\n\t\tlet path = [];\n\t\twhile(node !== startNode && node.parent.iterationID === inIteration){\n\t\t\tpath.push(node);\n\t\t\tnode = node.parent.node;\n\t\t}\n\t\tpath.reverse();\n\t\treturn path;\n\t}\n\n\tbiBackTrace(node1, startNode, node2, endNode){\n\t\tlet path1 = this.backTrace(node1, startNode),\n\t\t\tpath2 = this.backTrace(node2, endNode);\n\t\tpath2.reverse();\n\t\tlet path = path1.concat(path2);\n\t\treturn path;\n\t}\n\n\tgetInterpolation(grid, firstNode, secondNode){\n\t\tlet x1 = firstNode.x,\n\t\t\ty1 = firstNode.y,\n\t\t\tx2 = secondNode.x,\n\t\t\ty2 = secondNode.y,\n\t\t\txDifference = Math.abs(x2 - x1),\n\t\t\tyDifference = Math.abs(y2 - y1),\n\t\t\txDirection = (x2>x1) ? 1 : -1,\n\t\t\tyDirection = (y2>y1) ? 1 : -1,\n\t\t\tinterpolatedValues = [],\n\t\t\tintermidateDistance;\n\n\t\tintermidateDistance = xDifference - yDifference;\n\n\t\twhile((x1 !== x2) || (y1 !== y2)){\n\t\t\tinterpolatedValues.push(firstNode);\n\t\t\tif (2 *intermidateDistance > -yDifference){\n\t\t\t\tintermidateDistance = intermidateDistance - yDifference;\n\t\t\t\tx1 = x1 +xDirection;\n\t\t\t} else if (2*intermidateDistance < xDifference){\n\t\t\t\tintermidateDistance = intermidateDistance +xDifference;\n\t\t\t\ty1 = y1 +yDirection;\n\t\t\t}\n\t\t\tfirstNode = grid.getNodeAtXY(x1, y1);\n\t\t}\n\t\treturn interpolatedValues;\n\t}\n\n\texpandPath(grid, path, startNode){\n\t\tlet expandedPath =[],\n\t\t\tfirstNode,\n\t\t\tsecondNode,\n\t\t\tinterpolatedValues = [];\n\n\t\tfirstNode = startNode;\n\t\twhile(path.length){\n\t\t\tsecondNode = path.shift();\n\t\t\tinterpolatedValues = this.getInterpolation(grid, firstNode, secondNode);\n\t\t\twhile(interpolatedValues.length){\n\t\t\t\texpandedPath.push(interpolatedValues.shift());\n\t\t\t}\n\t\t\tfirstNode = secondNode;\n\t\t}\n\n\t\texpandedPath.push(secondNode);\n\t\texpandedPath.shift();\n\t\treturn expandedPath;\n\t}\n}\n\nexport default new BackTrace();\n","let abs = Math.abs,\n\tsqrt = Math.sqrt,\n\tmax = Math.max,\n\tmin = Math.min;\n\nclass Heuristic{\n\n\tmanhattan(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*(dx+dy);\n\t}\n\n\teuclidean(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*sqrt(dx*dx + dy*dy);\n\t}\n\n\toctile(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*(max(dx, dy)+(sqrt(2)-1)*min(dx, dy));\n\t}\n\n\tchebyshev(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*(max(dx, dy));\n\t}\n}\n\nexport default new Heuristic();\n"],"sourceRoot":""}