{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/./node_modules/denque/index.js","webpack://[name]/./node_modules/heap/index.js","webpack://[name]/./node_modules/heap/lib/heap.js","webpack://[name]/./src/PathFinding/algorithms/AStar.js","webpack://[name]/./src/PathFinding/algorithms/BreadthFirstSearch.js","webpack://[name]/./src/PathFinding/core/GraphNode.js","webpack://[name]/./src/PathFinding/core/Grid.js","webpack://[name]/./src/PathFinding/index.js","webpack://[name]/./src/PathFinding/utils/BackTrace.js","webpack://[name]/./src/PathFinding/utils/Heuristics.js"],"names":["AStar","options","console","log","heuristic","allowDiagonal","biDirectional","doNotCrossCornersBetweenObstacles","currentProcessingNode","neighbour","Math","abs","x","y","SQRT2","grid","minHeap","Heap","node1","node2","f","startNode","getNodeAtXY","startPoint","endNode","endPoint","neighbours","neighbourGValFromCurrentProcessingNode","g","insert","addedToHeap","empty","pop","currentNode","backTrace","getNeighbours","forEach","visited","getDistanceFromCurrentProcessignNode","h","heuristics","parent","updateItem","BreadthFirstSearch","queue","Denque","addedToQueue","isEmpty","shift","push","GraphNode","Grid","rows","columns","Array","isWall","isXYWallElement","makeXYWall","node","a","b","c","d","BackTrace","path","reverse","sqrt","max","min","Heuristic","weight","nodeA","nodeB","dx","dy"],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,GAAG;AACH,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,eAAe,gBAAgB;AAC/B,GAAG;AACH,wBAAwB,gBAAgB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACpbA,iBAAiB,mBAAO,CAAC,mDAAY;;;;;;;;;;;;ACArC;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mCAAmC,0BAA0B,oBAAoB;AACvI;AACA,KAAK;AACL;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC;AACxF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA,QAAQ,IAA0C;AAClD,aAAa,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAChC,KAAK,MAAM,EAIN;AACL,GAAG;AACH;AACA,GAAG;;AAEH,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACtXD;AACA;AACA;;IAEqBA,K;AACpB,iBAAYC,OAAZ,EAAoB;AAAA;;AACnBC,WAAO,CAACC,GAAR,CAAYF,OAAZ;AACA,SAAKG,SAAL,GAAiBH,OAAO,CAACG,SAAzB;AACA,SAAKC,aAAL,GAAqBJ,OAAO,CAACI,aAA7B;AACA,SAAKC,aAAL,GAAqBL,OAAO,CAACK,aAA7B;AACA,SAAKC,iCAAL,GAAyCN,OAAO,CAACM,iCAAjD;AACA;;;;yDAEoCC,qB,EAAuBC,S,EAAU;AACrE,UAAIC,IAAI,CAACC,GAAL,CAASH,qBAAqB,CAACI,CAAtB,GAAwBH,SAAS,CAACG,CAA3C,IAA8CF,IAAI,CAACC,GAAL,CAASH,qBAAqB,CAACK,CAAtB,GAAwBJ,SAAS,CAACI,CAA3C,CAA/C,KAAgG,CAAnG,EAAqG;AACpG,eAAO,CAAP;AACA;;AACD,aAAOH,IAAI,CAACI,KAAZ;AACA;;;6BAEQC,I,EAAK;AAAA;;AACb,UAAIC,OAAO,GAAG,IAAIC,2CAAJ,CAAS,UAACC,KAAD,EAAQC,KAAR;AAAA,eAAkBD,KAAK,CAACE,CAAN,GAAQD,KAAK,CAACC,CAAhC;AAAA,OAAT,CAAd;AAAA,UACCC,SAAS,GAAGN,IAAI,CAACO,WAAL,CAAiBP,IAAI,CAACQ,UAAL,CAAgBX,CAAjC,EAAoCG,IAAI,CAACQ,UAAL,CAAgBV,CAApD,CADb;AAAA,UAECW,OAAO,GAAGT,IAAI,CAACO,WAAL,CAAiBP,IAAI,CAACU,QAAL,CAAcb,CAA/B,EAAkCG,IAAI,CAACU,QAAL,CAAcZ,CAAhD,CAFX;AAAA,UAGCL,qBAHD;AAAA,UAICkB,UAJD;AAAA,UAKCC,sCALD;AAOAN,eAAS,CAACD,CAAV,GAAc,CAAd;AACAC,eAAS,CAACO,CAAV,GAAc,CAAd;AAEAZ,aAAO,CAACa,MAAR,CAAeR,SAAf;AACAA,eAAS,CAACS,WAAV,GAAwB,IAAxB;;AAEA,aAAM,CAACd,OAAO,CAACe,KAAR,EAAP,EAAuB;AACtBvB,6BAAqB,GAAGQ,OAAO,CAACgB,GAAR,EAAxB;AACAxB,6BAAqB,CAACyB,WAAtB,GAAoC,IAApC;;AAEA,YAAGzB,qBAAqB,KAAKgB,OAA7B,EAAqC;AACpC,iBAAOU,wDAAS,CAACA,SAAV,CAAoB1B,qBAApB,EAA2Ca,SAA3C,CAAP;AACA;;AAEDK,kBAAU,GAAGX,IAAI,CAACoB,aAAL,CAAmB3B,qBAAnB,EAA0C,KAAKH,aAA/C,EAA8D,KAAKE,iCAAnE,CAAb;AAEAmB,kBAAU,CAACU,OAAX,CAAmB,UAAA3B,SAAS,EAAI;AAC/B,cAAGA,SAAS,CAAC4B,OAAb,EAAsB,OADS,CACD;;AAE9BV,gDAAsC,GAAGnB,qBAAqB,CAACoB,CAAtB,GAAwB,KAAI,CAACU,oCAAL,CAA0C9B,qBAA1C,EAAiEC,SAAjE,CAAjE;;AAEA,cAAG,CAACA,SAAS,CAACqB,WAAd,EAA0B;AACzBrB,qBAAS,CAACmB,CAAV,GAAcD,sCAAd;AACAlB,qBAAS,CAAC8B,CAAV,GAAcC,yDAAU,CAAC,KAAI,CAACpC,SAAN,CAAV,CAA2BoB,OAA3B,EAAoCf,SAApC,CAAd;AACAA,qBAAS,CAACW,CAAV,GAAcX,SAAS,CAACmB,CAAV,GAAYnB,SAAS,CAAC8B,CAApC;AAEAvB,mBAAO,CAACa,MAAR,CAAepB,SAAf;AACAA,qBAAS,CAACqB,WAAV,GAAwB,IAAxB;AACArB,qBAAS,CAACgC,MAAV,GAAmBjC,qBAAnB;AAEA,WATD,MASO,IAAGC,SAAS,CAACmB,CAAV,GAAcD,sCAAjB,EAAwD;AAC9DlB,qBAAS,CAACmB,CAAV,GAAcD,sCAAd;AACAlB,qBAAS,CAAC8B,CAAV,GAAcC,yDAAU,CAAC,KAAI,CAACpC,SAAN,CAAV,CAA2BoB,OAA3B,EAAoCf,SAApC,CAAd;AACAA,qBAAS,CAACW,CAAV,GAAcX,SAAS,CAACmB,CAAV,GAAYnB,SAAS,CAAC8B,CAApC;AAEAvB,mBAAO,CAAC0B,UAAR,CAAmBjC,SAAnB;AACAA,qBAAS,CAACgC,MAAV,GAAmBjC,qBAAnB;AACA;AACD,SAtBD;AAwBAA,6BAAqB,CAAC6B,OAAtB,GAAgC,IAAhC;AACA;;AAED,aAAO,EAAP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxEF;AACA;;IAEqBM,kB;AACpB,8BAAY1C,OAAZ,EAAoB;AAAA;;AACnBC,WAAO,CAACC,GAAR,CAAYF,OAAZ;AACA,SAAKI,aAAL,GAAqBJ,OAAO,CAACI,aAA7B;AACA,SAAKC,aAAL,GAAqBL,OAAO,CAACK,aAA7B;AACA,SAAKC,iCAAL,GAAyCN,OAAO,CAACM,iCAAjD;AACA;;;;6BAEQQ,I,EAAK;AACb,UAAIQ,UAAU,GAAGR,IAAI,CAACQ,UAAtB;AAAA,UACCE,QAAQ,GAAGV,IAAI,CAACU,QADjB;AAAA,UAECJ,SAAS,GAAGN,IAAI,CAACQ,UAAU,CAACV,CAAZ,CAAJ,CAAmBU,UAAU,CAACX,CAA9B,CAFb;AAAA,UAGCY,OAAO,GAAGT,IAAI,CAACU,QAAQ,CAACZ,CAAV,CAAJ,CAAiBY,QAAQ,CAACb,CAA1B,CAHX;AAKA,UAAIgC,KAAK,GAAG,IAAIC,6CAAJ,CAAW,CAACxB,SAAD,CAAX,CAAZ;AAAA,UACCK,UAAU,GAAG,EADd;AAAA,UAEClB,qBAFD;AAGAa,eAAS,CAACyB,YAAV,GAAyB,IAAzB;;AAEA,aAAM,CAACF,KAAK,CAACG,OAAN,EAAP,EAAuB;AAEtBvC,6BAAqB,GAAGoC,KAAK,CAACI,KAAN,EAAxB,CAFsB,CAEiB;;AACvCxC,6BAAqB,CAACyB,WAAtB,GAAoC,IAApC;;AAEA,YAAGzB,qBAAqB,KAAKgB,OAA7B,EAAqC;AACpC,iBAAOU,wDAAS,CAACA,SAAV,CAAoBV,OAApB,EAA6BH,SAA7B,CAAP;AACA;;AAEDK,kBAAU,GAAGX,IAAI,CAACoB,aAAL,CAAmB3B,qBAAnB,EAA0C,KAAKH,aAA/C,EAA8D,KAAKE,iCAAnE,CAAb;AACAmB,kBAAU,CAACU,OAAX,CAAmB,UAAA3B,SAAS,EAAI;AAC/B,cAAGA,SAAS,CAAC4B,OAAV,IAAqB5B,SAAS,CAACqC,YAAlC,EAA+C;AAC9C,mBAD8C,CACtC;AACR;;AACDF,eAAK,CAACK,IAAN,CAAWxC,SAAX;AACAA,mBAAS,CAACqC,YAAV,GAAyB,IAAzB;AACArC,mBAAS,CAACgC,MAAV,GAAmBjC,qBAAnB;AACA,SAPD;AAQAA,6BAAqB,CAAC6B,OAAtB,GAAgC,IAAhC;AACA;;AAED,aAAO,EAAP;AACA;;;;;;;;;;;;;;;;;;;;;IC5CIa,S,GACL,mBAAYjD,OAAZ,EAAoB;AAAA;;AACnB,OAAKW,CAAL,GAASX,OAAO,CAACW,CAAjB;AACA,OAAKC,CAAL,GAASZ,OAAO,CAACY,CAAjB;AACA,C;;AAGaqC,wEAAf,E;;;;;;;;;;;;;;;;;;;;ACPA;;IAEMC,I;AACL,gBAAYlD,OAAZ,EAAoB;AAAA;;AACnB,SAAKmD,IAAL,GAAYnD,OAAO,CAACmD,IAApB;AACA,SAAKC,OAAL,GAAepD,OAAO,CAACoD,OAAvB;AACA,SAAK9B,UAAL,GAAkBtB,OAAO,CAACsB,UAA1B;AACA,SAAKE,QAAL,GAAgBxB,OAAO,CAACwB,QAAxB;;AAEA,SAAI,IAAIZ,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,KAAKuC,IAApB,EAA0BvC,CAAC,EAA3B,EAA8B;AAC7B,WAAKA,CAAL,IAAU,IAAIyC,KAAJ,CAAU,KAAKD,OAAf,CAAV;;AACA,WAAI,IAAIzC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,KAAKyC,OAApB,EAA6BzC,CAAC,EAA9B,EAAiC;AAChC,aAAKC,CAAL,EAAQD,CAAR,IAAa,IAAIsC,kDAAJ,CAAc;AAACtC,WAAC,EAADA,CAAD;AAAIC,WAAC,EAADA;AAAJ,SAAd,CAAb;AACA;AACD;AACD;;;;oCAEeD,C,EAAGC,C,EAAE;AACpB,UAAGD,CAAC,GAAC,CAAF,IAAOA,CAAC,IAAE,KAAKyC,OAAf,IAA0BxC,CAAC,GAAC,CAA5B,IAAiCA,CAAC,IAAE,KAAKuC,IAA5C,EAAkD,OAAO,IAAP;AAClD,aAAQ,KAAKvC,CAAL,EAAQD,CAAR,EAAW2C,MAAX,GAAkB,IAAlB,GAAuB,KAA/B;AACA;;;+BAEU3C,C,EAAGC,C,EAAE;AACf,WAAKA,CAAL,EAAQD,CAAR,EAAW2C,MAAX,GAAoB,IAApB;AACA;;;oCAEe3C,C,EAAGC,C,EAAE;AACpB,WAAKA,CAAL,EAAQD,CAAR,EAAW2C,MAAX,GAAoB,KAApB;AACA;;;mCAEc3C,C,EAAGC,C,EAAE;AACnB,aAAS,KAAKU,UAAL,CAAgBX,CAAhB,KAAsBA,CAAvB,IAA6B,KAAKW,UAAL,CAAgBV,CAAhB,KAAsBA,CAA3D;AACA;;;iCAEYD,C,EAAGC,C,EAAE;AACjB,aAAS,KAAKY,QAAL,CAAcb,CAAd,KAAoBA,CAArB,IAA2B,KAAKa,QAAL,CAAcZ,CAAd,KAAoBA,CAAvD;AACA;;;gCAEWD,C,EAAGC,C,EAAE;AAChB,aAAO,KAAKA,CAAL,EAAQD,CAAR,CAAP;AACA;;;4BAEM;AACN,UAAIG,IAAI,GAAG,IAAIoC,IAAJ,CAAS,IAAT,CAAX;;AAEA,WAAI,IAAItC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,KAAKuC,IAApB,EAA0BvC,CAAC,EAA3B,EAA8B;AAC7BE,YAAI,CAACF,CAAD,CAAJ,GAAU,IAAIyC,KAAJ,CAAU,KAAKD,OAAf,CAAV;;AACA,aAAI,IAAIzC,CAAC,GAAC,CAAV,EAAaA,CAAC,GAAC,KAAKyC,OAApB,EAA6BzC,CAAC,EAA9B,EAAiC;AAChCG,cAAI,CAACF,CAAD,CAAJ,CAAQD,CAAR,IAAa,IAAIsC,kDAAJ,CAAc;AAACtC,aAAC,EAADA,CAAD;AAAIC,aAAC,EAADA;AAAJ,WAAd,CAAb;AACA,cAAG,KAAK2C,eAAL,CAAqB5C,CAArB,EAAwBC,CAAxB,CAAH,EAA+BE,IAAI,CAAC0C,UAAL,CAAgB7C,CAAhB,EAAmBC,CAAnB;AAC/B;AACD;;AACD,aAAOE,IAAP;AACA;AAED;;;;;;;;kCAKc2C,I,EAAMrD,a,EAAeE,iC,EAAkC;AACpE,UAAImB,UAAU,GAAG,EAAjB;AADoE,UAE7Dd,CAF6D,GAErD8C,IAFqD,CAE7D9C,CAF6D;AAAA,UAE1DC,CAF0D,GAErD6C,IAFqD,CAE1D7C,CAF0D;AAGpE,UAAI8C,CAAJ,EAAOC,CAAP,EAAUC,CAAV,EAAaC,CAAb,CAHoE,CAKpE;;AACA,UAAG,CAAC,KAAKN,eAAL,CAAqB5C,CAArB,EAAwBC,CAAC,GAAC,CAA1B,CAAJ,EAAkC;AACjCa,kBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAjB,EAAoBC,CAAC,GAAC,CAAtB,CAAhB;AACA8C,SAAC,GAAG,IAAJ;AACA,OATmE,CAUpE;;;AACA,UAAG,CAAC,KAAKH,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAA1B,CAAJ,EAAkC;AACjCa,kBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAtB,CAAhB;AACA+C,SAAC,GAAG,IAAJ;AACA,OAdmE,CAepE;;;AACA,UAAG,CAAC,KAAKJ,eAAL,CAAqB5C,CAArB,EAAwBC,CAAC,GAAC,CAA1B,CAAJ,EAAkC;AACjCa,kBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAjB,EAAoBC,CAAC,GAAC,CAAtB,CAAhB;AACAgD,SAAC,GAAG,IAAJ;AACA,OAnBmE,CAoBpE;;;AACA,UAAG,CAAC,KAAKL,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAA1B,CAAJ,EAAkC;AACjCa,kBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAtB,CAAhB;AACAiD,SAAC,GAAG,IAAJ;AACA;;AAED,UAAGzD,aAAH,EAAiB;AAChB,YAAGE,iCAAH,EAAqC;AACpC;AACA,cAAI,CAACoD,CAAC,IAAIG,CAAN,IAAW,CAAC,KAAKN,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAhB,EAAgD;AAC/Ca,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA,WAJmC,CAKpC;;;AACA,cAAI,CAAC8C,CAAC,IAAIC,CAAN,IAAW,CAAC,KAAKJ,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAhB,EAAgD;AAC/Ca,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA,WARmC,CASpC;;;AACA,cAAI,CAAC+C,CAAC,IAAIC,CAAN,IAAW,CAAC,KAAKL,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAhB,EAAgD;AAC/Ca,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA,WAZmC,CAapC;;;AACA,cAAI,CAACgD,CAAC,IAAIC,CAAN,IAAW,CAAC,KAAKN,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAhB,EAAgD;AAC/Ca,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA;AACD,SAjBD,MAiBO;AACN;AACA,cAAG,CAAC,KAAK2C,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAJ,EAAoC;AACnCa,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA,WAJK,CAKN;;;AACA,cAAG,CAAC,KAAK2C,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAJ,EAAoC;AACnCa,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA,WARK,CASN;;;AACA,cAAG,CAAC,KAAK2C,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAJ,EAAoC;AACnCa,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA,WAZK,CAaN;;;AACA,cAAG,CAAC,KAAK2C,eAAL,CAAqB5C,CAAC,GAAC,CAAvB,EAA0BC,CAAC,GAAC,CAA5B,CAAJ,EAAoC;AACnCa,sBAAU,CAACuB,IAAX,CAAgB,KAAK3B,WAAL,CAAiBV,CAAC,GAAC,CAAnB,EAAsBC,CAAC,GAAC,CAAxB,CAAhB;AACA;AACD;AACD;;AACD,aAAOa,UAAP;AACA;;;;;;AAGayB,mEAAf,E;;;;;;;;;;;;AC/HA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEe;AACdA,MAAI,EAAJA,kDADc;AAEdD,WAAS,EAATA,uDAFc;AAGdP,oBAAkB,EAAlBA,sEAHc;AAId3C,OAAK,EAALA,yDAAKA;AAJS,CAAf,E;;;;;;;;;;;;;;;;;;;ICLM+D,S;;;;;;;8BACKL,I,EAAMrC,S,EAAU;AACzB,UAAI2C,IAAI,GAAG,EAAX;;AACA,aAAMN,IAAI,KAAKrC,SAAf,EAAyB;AACxB2C,YAAI,CAACf,IAAL,CAAUS,IAAV;AACAA,YAAI,GAAGA,IAAI,CAACjB,MAAZ;AACA;;AACDuB,UAAI,CAACC,OAAL;AACA,aAAOD,IAAP;AACA;;;;;;AAGa,mEAAID,SAAJ,EAAf,E;;;;;;;;;;;;;;;;;;;ACZA,IAAIpD,GAAG,GAAGD,IAAI,CAACC,GAAf;AAAA,IACCuD,IAAI,GAAGxD,IAAI,CAACwD,IADb;AAAA,IAECC,GAAG,GAAGzD,IAAI,CAACyD,GAFZ;AAAA,IAGCC,GAAG,GAAG1D,IAAI,CAAC0D,GAHZ;;IAKMC,S;AAEL,uBAAa;AAAA;;AACZ,SAAKC,MAAL,GAAc,CAAd;AACA;;;;8BAESC,K,EAAOC,K,EAAM;AACtB,UAAIC,EAAE,GAAG9D,GAAG,CAAC4D,KAAK,CAAC3D,CAAN,GAAQ4D,KAAK,CAAC5D,CAAf,CAAZ;AACA,UAAI8D,EAAE,GAAG/D,GAAG,CAAC4D,KAAK,CAAC1D,CAAN,GAAQ2D,KAAK,CAAC3D,CAAf,CAAZ;AACA,aAAO,KAAKyD,MAAL,IAAaG,EAAE,GAACC,EAAhB,CAAP;AACA;;;8BAESH,K,EAAOC,K,EAAM;AACtB,UAAIC,EAAE,GAAG9D,GAAG,CAAC4D,KAAK,CAAC3D,CAAN,GAAQ4D,KAAK,CAAC5D,CAAf,CAAZ;AACA,UAAI8D,EAAE,GAAG/D,GAAG,CAAC4D,KAAK,CAAC1D,CAAN,GAAQ2D,KAAK,CAAC3D,CAAf,CAAZ;AACA,aAAO,KAAKyD,MAAL,GAAYJ,IAAI,CAACO,EAAE,GAACA,EAAH,GAAQC,EAAE,GAACA,EAAZ,CAAvB;AACA;;;2BAEMH,K,EAAOC,K,EAAM;AACnB,UAAIC,EAAE,GAAG9D,GAAG,CAAC4D,KAAK,CAAC3D,CAAN,GAAQ4D,KAAK,CAAC5D,CAAf,CAAZ;AACA,UAAI8D,EAAE,GAAG/D,GAAG,CAAC4D,KAAK,CAAC1D,CAAN,GAAQ2D,KAAK,CAAC3D,CAAf,CAAZ;AACA,aAAOsD,GAAG,CAACM,EAAD,EAAKC,EAAL,CAAH,GAAY,CAACR,IAAI,CAAC,CAAD,CAAJ,GAAQ,CAAT,IAAYE,GAAG,CAACK,EAAD,EAAKC,EAAL,CAAlC;AACA;;;8BAESH,K,EAAOC,K,EAAM;AACtB,UAAIC,EAAE,GAAG9D,GAAG,CAAC4D,KAAK,CAAC3D,CAAN,GAAQ4D,KAAK,CAAC5D,CAAf,CAAZ;AACA,UAAI8D,EAAE,GAAG/D,GAAG,CAAC4D,KAAK,CAAC1D,CAAN,GAAQ2D,KAAK,CAAC3D,CAAf,CAAZ;AACA,aAAOsD,GAAG,CAACM,EAAD,EAAKC,EAAL,CAAV;AACA;;;;;;AAGa,mEAAIL,SAAJ,EAAf,E","file":"PathFinder.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/PathFinding/index.js\");\n","'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array) {\n  this._head = 0;\n  this._tail = 0;\n  this._capacityMask = 0x3;\n  this._list = new Array(4);\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  }\n}\n\n/**\n * -------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peakAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (item === undefined) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (item === undefined) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = ( i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  for (var i = 0; i < array.length; i++) this.push(array[i]);\n};\n\n/**\n *\n * @param fullCopy\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy) {\n  var newArray = [];\n  var list = this._list;\n  var len = list.length;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < len; i++) newArray.push(list[i]);\n    for (i = 0; i < this._tail; i++) newArray.push(list[i]);\n  } else {\n    for (i = this._head; i < this._tail; i++) newArray.push(list[i]);\n  }\n  return newArray;\n};\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head) {\n    // copy existing data, head to end, then beginning to tail.\n    this._list = this._copyArray(true);\n    this._head = 0;\n  }\n\n  // head is at 0 and array is now full, safe to extend\n  this._tail = this._list.length;\n\n  this._list.length *= 2;\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n\nmodule.exports = Denque;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","import Heap from 'heap';\nimport backTrace from '../utils/BackTrace';\nimport heuristics from '../utils/Heuristics';\n\nexport default class AStar{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.heuristic = options.heuristic;\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t}\n\n\tgetDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour){\n\t\tif((Math.abs(currentProcessingNode.x-neighbour.x)+Math.abs(currentProcessingNode.y-neighbour.y))===1){\n\t\t\treturn 1;\n\t\t}\n\t\treturn Math.SQRT2;\n\t}\n\n\tfindPath(grid){\n\t\tlet minHeap = new Heap((node1, node2) => node1.f-node2.f), \n\t\t\tstartNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y), \n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y), \n\t\t\tcurrentProcessingNode, \n\t\t\tneighbours, \n\t\t\tneighbourGValFromCurrentProcessingNode;\n\t\t\n\t\tstartNode.f = 0;\n\t\tstartNode.g = 0;\n\n\t\tminHeap.insert(startNode);\n\t\tstartNode.addedToHeap = true;\n\n\t\twhile(!minHeap.empty()){\n\t\t\tcurrentProcessingNode = minHeap.pop();\n\t\t\tcurrentProcessingNode.currentNode = true;\n\n\t\t\tif(currentProcessingNode === endNode){\n\t\t\t\treturn backTrace.backTrace(currentProcessingNode, startNode);\n\t\t\t}\n\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited) return; //equivalent to continue in forEach\n\t\t\t\t\n\t\t\t\tneighbourGValFromCurrentProcessingNode = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\tneighbour.h = heuristics[this.heuristic](endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\n\t\t\t\t} else if(neighbour.g > neighbourGValFromCurrentProcessingNode){\n\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\tneighbour.h = heuristics[this.heuristic](endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.updateItem(neighbour);\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n}\n","import Denque from 'denque';\nimport backTrace from '../utils/BackTrace';\n\nexport default class BreadthFirstSearch{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t}\n\n\tfindPath(grid){\n\t\tlet startPoint = grid.startPoint, \n\t\t\tendPoint = grid.endPoint, \n\t\t\tstartNode = grid[startPoint.y][startPoint.x], \n\t\t\tendNode = grid[endPoint.y][endPoint.x];\n\n\t\tlet queue = new Denque([startNode]), \n\t\t\tneighbours = [], \n\t\t\tcurrentProcessingNode;\n\t\tstartNode.addedToQueue = true;\n\n\t\twhile(!queue.isEmpty()){\n\n\t\t\tcurrentProcessingNode = queue.shift(); // Dequeue operation on queue\n\t\t\tcurrentProcessingNode.currentNode = true;\n\t\t\t\n\t\t\tif(currentProcessingNode === endNode){\n\t\t\t\treturn backTrace.backTrace(endNode, startNode);\n\t\t\t}\n\t\t\t\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited || neighbour.addedToQueue){\n\t\t\t\t\treturn; // equivalent to CONTINUE in forEach\n\t\t\t\t}\n\t\t\t\tqueue.push(neighbour);\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t});\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n}\n","class GraphNode{\n\tconstructor(options){\n\t\tthis.x = options.x;\n\t\tthis.y = options.y;\n\t}\n}\n\nexport default GraphNode;\n","import GraphNode from './GraphNode';\n\nclass Grid{\n\tconstructor(options){\n\t\tthis.rows = options.rows;\n\t\tthis.columns = options.columns;\n\t\tthis.startPoint = options.startPoint;\n\t\tthis.endPoint = options.endPoint;\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tthis[y] = new Array(this.columns);\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tthis[y][x] = new GraphNode({x, y});\n\t\t\t}\n\t\t}\n\t}\n\n\tisXYWallElement(x, y){\n\t\tif(x<0 || x>=this.columns || y<0 || y>=this.rows) return true;\n\t\treturn (this[y][x].isWall?true:false);\n\t}\n\n\tmakeXYWall(x, y){\n\t\tthis[y][x].isWall = true;\n\t}\n\n\tdestroyWallAtXY(x, y){\n\t\tthis[y][x].isWall = false;\n\t}\n\n\tisXYStartPoint(x, y){\n\t\treturn ((this.startPoint.x === x )&&(this.startPoint.y === y));\n\t}\n\n\tisXYEndPoint(x, y){\n\t\treturn ((this.endPoint.x === x )&&(this.endPoint.y === y));\n\t}\n\n\tgetNodeAtXY(x, y){\n\t\treturn this[y][x];\n\t}\n\n\tclone(){\n\t\tlet grid = new Grid(this);\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tgrid[y] = new Array(this.columns);\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tgrid[y][x] = new GraphNode({x, y});\n\t\t\t\tif(this.isXYWallElement(x, y)) grid.makeXYWall(x, y);\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\n\t/*\n\t\t|_ _|_a_|_ _| |_p_|_ _|_q_| \n\t\t|_d_|_*_|_b_| |_ _|_*_|_ _|\n\t\t|_ _|_c_|_ _| |_s_|_ _|_r_|\n\t */\n\tgetNeighbours(node, allowDiagonal, doNotCrossCornersBetweenObstacles){\n\t\tlet neighbours = [];\n\t\tconst {x, y} = node;\n\t\tlet a, b, c, d;\n\t\t\n\t\t// a\n\t\tif(!this.isXYWallElement(x, y-1)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x, y-1));\n\t\t\ta = true;\n\t\t}\n\t\t// b\n\t\tif(!this.isXYWallElement(x+1, y)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x+1, y));\n\t\t\tb = true;\n\t\t}\n\t\t// c\n\t\tif(!this.isXYWallElement(x, y+1)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x, y+1));\n\t\t\tc = true;\n\t\t}\n\t\t// d\n\t\tif(!this.isXYWallElement(x-1, y)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x-1, y));\n\t\t\td = true;\n\t\t}\n\n\t\tif(allowDiagonal){\n\t\t\tif(doNotCrossCornersBetweenObstacles){\n\t\t\t\t//p\n\t\t\t\tif( (a || d) & !this.isXYWallElement(x-1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y-1));\n\t\t\t\t}\n\t\t\t\t//q\n\t\t\t\tif( (a || b) & !this.isXYWallElement(x+1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y-1));\n\t\t\t\t}\n\t\t\t\t//r\n\t\t\t\tif( (b || c) & !this.isXYWallElement(x+1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y+1));\n\t\t\t\t}\n\t\t\t\t//s\n\t\t\t\tif( (c || d) & !this.isXYWallElement(x-1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y+1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//p\n\t\t\t\tif(!this.isXYWallElement(x-1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y-1));\n\t\t\t\t}\n\t\t\t\t//q\n\t\t\t\tif(!this.isXYWallElement(x+1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y-1));\n\t\t\t\t}\n\t\t\t\t//r\n\t\t\t\tif(!this.isXYWallElement(x+1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y+1));\n\t\t\t\t}\n\t\t\t\t//s\n\t\t\t\tif(!this.isXYWallElement(x-1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn neighbours;\n\t}\n}\n\nexport default Grid;\n","import Grid from './core/Grid';\nimport GraphNode from './core/GraphNode';\nimport BreadthFirstSearch from './algorithms/BreadthFirstSearch';\nimport AStar from './algorithms/AStar';\n\nexport default {\n\tGrid, \n\tGraphNode, \n\tBreadthFirstSearch, \n\tAStar\n};\n","class BackTrace{\n\tbackTrace(node, startNode){\n\t\tlet path = [];\n\t\twhile(node !== startNode){\n\t\t\tpath.push(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\tpath.reverse();\n\t\treturn path;\n\t}\n}\n\nexport default new BackTrace();\n","let abs = Math.abs, \n\tsqrt = Math.sqrt, \n\tmax = Math.max, \n\tmin = Math.min;\n\nclass Heuristic{\n\n\tconstructor(){\n\t\tthis.weight = 1;\n\t}\n\n\tmanhattan(nodeA, nodeB){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn this.weight*(dx+dy);\n\t}\n\n\teuclidean(nodeA, nodeB){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn this.weight*sqrt(dx*dx + dy*dy);\n\t}\n\n\toctile(nodeA, nodeB){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn max(dx, dy)+(sqrt(2)-1)*min(dx, dy);\n\t}\n\n\tchebyshev(nodeA, nodeB){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn max(dx, dy);\n\t}\n}\n\nexport default new Heuristic();\n"],"sourceRoot":""}