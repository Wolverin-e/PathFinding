{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/./node_modules/denque/index.js","webpack://[name]/./node_modules/heap/index.js","webpack://[name]/./node_modules/heap/lib/heap.js","webpack://[name]/./src/PathFinding/algorithms/AStar.js","webpack://[name]/./src/PathFinding/algorithms/BestFirstSearch.js","webpack://[name]/./src/PathFinding/algorithms/BreadthFirstSearch.js","webpack://[name]/./src/PathFinding/algorithms/Dijkshtra.js","webpack://[name]/./src/PathFinding/algorithms/IDAStar.js","webpack://[name]/./src/PathFinding/algorithms/IDDFS.js","webpack://[name]/./src/PathFinding/algorithms/JumpPointSearch.js","webpack://[name]/./src/PathFinding/algorithms/MultiBFS.js","webpack://[name]/./src/PathFinding/core/GraphNode.js","webpack://[name]/./src/PathFinding/core/Grid.js","webpack://[name]/./src/PathFinding/core/MultiEPGrid.js","webpack://[name]/./src/PathFinding/index.js","webpack://[name]/./src/PathFinding/utils/BackTrace.js","webpack://[name]/./src/PathFinding/utils/Heuristics.js"],"names":["AStar","options","console","log","allowDiagonal","biDirectional","doNotCrossCornersBetweenObstacles","markCurrentProcessingNode","heuristic","heuristics","findPath","findBiPath","currentProcessingNode","neighbour","Math","abs","x","y","SQRT2","grid","minHeap","Heap","node1","node2","f","startNode","getNodeAtXY","startPoint","endNode","endPoint","neighbours","neighbourGValFromCurrentProcessingNode","g","insert","addedToHeap","empty","pop","currentNode","backTrace","getNeighbours","forEach","visited","getDistanceFromCurrentProcessignNode","h","parent","updateItem","minHeapFromStart","minHeapFromEnd","by","length","shift","biBackTrace","BestFirstSearch","heuristicToOverride","BreadthFirstSearch","queue","Denque","addedToQueue","isEmpty","doNotCrossCorners","push","startNeighbours","endNeighbours","startQueue","endQueue","Dijkshtra","Array","prototype","peekTop","undefined","IDAStar","timeLimit","rootNode","startTime","Date","uppperBound","returnedInstance","path","search","info","rootGVal","upperBound","timeUp","fVal","explored","min","Infinity","neighbourGVal","includes","getDistanceFromRootNode","IDDFS","JumpPointSearch","max","parentX","parentY","xNormalizeDirection","yNormalizeDirection","isXYWallElement","xDifference","yDifference","processed","getJumpPoints","columns","rows","jumpPointNode","jumpPointDistanceFromStart","getNeighboursBasedOnOptions","jumpPoints","expandPath","successor","MultiBFS","multiEPGrid","isXYEndPoint","concat","removeEndPoint","endPoints","clear","clone","GraphNode","Grid","isWall","makeXYWall","node","a","b","c","d","MultiEPGrid","some","ep","from","to","i","findIndex","filter","BackTrace","reverse","path1","path2","firstNode","secondNode","x1","y1","x2","y2","xDirection","yDirection","interpolatedValues","intermidateDistance","expandedPath","getInterpolation","sqrt","Heuristic","nodeA","nodeB","weight","dx","dy"],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,GAAG;AACH,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC,eAAe,gBAAgB;AAC/B,GAAG;AACH,wBAAwB,gBAAgB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;;;;;;ACpbA,iBAAiB,mBAAO,CAAC,mDAAY;;;;;;;;;;;;ACArC;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mCAAmC,0BAA0B,oBAAoB;AACvI;AACA,KAAK;AACL;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC;AACxF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;AACA,QAAQ,IAA0C;AAClD,aAAa,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAChC,KAAK,MAAM,EAIN;AACL,GAAG;AACH;AACA,GAAG;;AAEH,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACtXD;AACA;AACA;;IAEqBA,K;AACpB,iBAAYC,OAAZ,EAAoB;AAAA;;AACnBC,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","file":"PathFinder.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/PathFinding/index.js\");\n","'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array) {\n  this._head = 0;\n  this._tail = 0;\n  this._capacityMask = 0x3;\n  this._list = new Array(4);\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  }\n}\n\n/**\n * -------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peakAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (item === undefined) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (item === undefined) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = ( i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  for (var i = 0; i < array.length; i++) this.push(array[i]);\n};\n\n/**\n *\n * @param fullCopy\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy) {\n  var newArray = [];\n  var list = this._list;\n  var len = list.length;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < len; i++) newArray.push(list[i]);\n    for (i = 0; i < this._tail; i++) newArray.push(list[i]);\n  } else {\n    for (i = this._head; i < this._tail; i++) newArray.push(list[i]);\n  }\n  return newArray;\n};\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head) {\n    // copy existing data, head to end, then beginning to tail.\n    this._list = this._copyArray(true);\n    this._head = 0;\n  }\n\n  // head is at 0 and array is now full, safe to extend\n  this._tail = this._list.length;\n\n  this._list.length *= 2;\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n\nmodule.exports = Denque;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","import Heap from 'heap';\nimport backTrace from '../utils/BackTrace';\nimport heuristics from '../utils/Heuristics';\n\nexport default class AStar{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t\tif(this.biDirectional){\n\t\t\tthis.findPath = this.findBiPath;\n\t\t}\n\t}\n\n\tgetDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour){\n\t\tif((Math.abs(currentProcessingNode.x-neighbour.x)+Math.abs(currentProcessingNode.y-neighbour.y))===1){\n\t\t\treturn 1;\n\t\t}\n\t\treturn Math.SQRT2;\n\t}\n\n\tfindPath(grid){\n\t\tlet minHeap = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tstartNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y),\n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tneighbourGValFromCurrentProcessingNode;\n\n\t\tstartNode.f = 0;\n\t\tstartNode.g = 0;\n\t\tendNode.f = 0;\n\t\tendNode.g = 0;\n\n\t\tminHeap.insert(startNode);\n\t\tstartNode.addedToHeap = true;\n\n\t\twhile(!minHeap.empty()){\n\t\t\tcurrentProcessingNode = minHeap.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\n\t\t\tif(currentProcessingNode === endNode){\n\t\t\t\treturn backTrace.backTrace(currentProcessingNode, startNode);\n\t\t\t}\n\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited) return; //equivalent to continue in forEach\n\n\t\t\t\tneighbourGValFromCurrentProcessingNode = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\n\t\t\t\t} else if(neighbour.g > neighbourGValFromCurrentProcessingNode){\n\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeap.updateItem(neighbour);\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tfindBiPath(grid){\n\t\tlet minHeapFromStart = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tminHeapFromEnd = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tstartNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y),\n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tneighbour,\n\t\t\tneighbourGValFromCurrentProcessingNode;\n\n\t\tstartNode.f = 0;\n\t\tstartNode.g = 0;\n\t\tendNode.f = 0;\n\t\tendNode.g = 0;\n\n\t\tminHeapFromStart.insert(startNode);\n\t\tstartNode.addedToHeap = true;\n\t\tstartNode.by = 'start';\n\t\tminHeapFromEnd.insert(endNode);\n\t\tendNode.addedToHeap = true;\n\t\tendNode.by = 'end';\n\n\t\twhile(!minHeapFromStart.empty() && !minHeapFromEnd.empty()){\n\n\t\t\tcurrentProcessingNode = minHeapFromStart.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(neighbours.length){\n\t\t\t\tneighbour = neighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tneighbourGValFromCurrentProcessingNode = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeapFromStart.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\tneighbour.by = 'start';\n\n\t\t\t\t} else {\n\t\t\t\t\tif(neighbour.by === 'end'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(currentProcessingNode, startNode, neighbour, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tif(neighbour.g > neighbourGValFromCurrentProcessingNode){\n\t\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\t\tneighbour.h = this.heuristic(endNode, neighbour);\n\t\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\t\tminHeapFromStart.updateItem(neighbour);\n\t\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\t\tneighbour.by = 'start';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentProcessingNode.visited = true;\n\n\t\t\tcurrentProcessingNode = minHeapFromEnd.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(neighbours.length){\n\t\t\t\tneighbour = neighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tneighbourGValFromCurrentProcessingNode = currentProcessingNode.g+this.getDistanceFromCurrentProcessignNode(currentProcessingNode, neighbour);\n\t\t\t\tif(!neighbour.addedToHeap){\n\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\tneighbour.h = this.heuristic(startNode, neighbour);\n\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\tminHeapFromEnd.insert(neighbour);\n\t\t\t\t\tneighbour.addedToHeap = true;\n\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\tneighbour.by = 'end';\n\n\t\t\t\t} else {\n\t\t\t\t\tif(neighbour.by === 'start'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(neighbour, startNode, currentProcessingNode, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tif(neighbour.g > neighbourGValFromCurrentProcessingNode){\n\t\t\t\t\t\tneighbour.g = neighbourGValFromCurrentProcessingNode;\n\t\t\t\t\t\tneighbour.h = this.heuristic(startNode, neighbour);\n\t\t\t\t\t\tneighbour.f = neighbour.g+neighbour.h;\n\n\t\t\t\t\t\tminHeapFromEnd.updateItem(neighbour);\n\t\t\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\t\t\tneighbour.by = 'end';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t}\n}\n","import AStar from './AStar';\n\nexport default class BestFirstSearch extends AStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tlet heuristicToOverride = this.heuristic;\n\n\t\tthis.heuristic = (node1, node2) => {\n\t\t\treturn heuristicToOverride(node1, node2, 500000);\n\t\t};\n\t}\n}\n","import Denque from 'denque';\nimport backTrace from '../utils/BackTrace';\n\nexport default class BreadthFirstSearch{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t\tif(this.biDirectional){\n\t\t\tthis.findPath = this.findBiPath;\n\t\t}\n\t}\n\n\tfindPath(grid){\n\t\tlet startPoint = grid.startPoint,\n\t\t\tendPoint = grid.endPoint,\n\t\t\tstartNode = grid[startPoint.y][startPoint.x],\n\t\t\tendNode = grid[endPoint.y][endPoint.x];\n\n\t\tlet queue = new Denque([startNode]),\n\t\t\tneighbours = [],\n\t\t\tcurrentProcessingNode;\n\n\t\tstartNode.addedToQueue = true;\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tcurrentProcessingNode = queue.shift(); // Dequeue operation on queue\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\n\t\t\tif(currentProcessingNode === endNode){\n\t\t\t\treturn backTrace.backTrace(endNode, startNode);\n\t\t\t}\n\n\t\t\tneighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCorners);\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.visited || neighbour.addedToQueue){\n\t\t\t\t\treturn; // equivalent to CONTINUE in forEach\n\t\t\t\t}\n\t\t\t\tqueue.push(neighbour);\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn [];\n\t}\n\n\tfindBiPath(grid){\n\t\tlet startNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y),\n\t\t\tendNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y),\n\t\t\tneighbour,\n\t\t\tcurrentProcessingNode,\n\t\t\tstartNeighbours = [],\n\t\t\tendNeighbours = [];\n\n\t\tlet startQueue = new Denque([startNode]),\n\t\t\tendQueue = new Denque([endNode]);\n\n\t\tstartNode.addedToQueue = true;\n\t\tendNode.addedToQueue = true;\n\t\tstartNode.by = 'start';\n\t\tendNode.by = 'end';\n\n\t\twhile(!startQueue.isEmpty() && !endQueue.isEmpty()){\n\t\t\tcurrentProcessingNode = startQueue.shift();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tstartNeighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(startNeighbours.length){\n\t\t\t\tneighbour = startNeighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(neighbour.addedToQueue){\n\t\t\t\t\tif(neighbour.by === 'end'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(currentProcessingNode, startNode, neighbour, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstartQueue.push(neighbour);\n\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t\tneighbour.by = 'start';\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t}\n\n\t\t\tcurrentProcessingNode.visited = true;\n\n\t\t\tcurrentProcessingNode = endQueue.shift();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\t\t\tendNeighbours = grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\t\twhile(endNeighbours.length){\n\t\t\t\tneighbour = endNeighbours.shift();\n\t\t\t\tif(neighbour.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(neighbour.addedToQueue){\n\t\t\t\t\tif(neighbour.by === 'start'){\n\t\t\t\t\t\treturn backTrace.biBackTrace(neighbour, startNode, currentProcessingNode, endNode);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tendQueue.push(neighbour);\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t\tneighbour.parent=currentProcessingNode;\n\t\t\t\tneighbour.by='end';\n\t\t\t}\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\t\treturn [];\n\t}\n}\n\n","import AStar from './AStar';\n\nexport default class Dijkshtra extends AStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.heuristic = () => {\n\t\t\treturn 0;\n\t\t};\n\t}\n}\n","import heuristics from '../utils/Heuristics';\n\nArray.prototype.peekTop = function(){\n\treturn this.length?this[this.length-1]:undefined;\n};\n\nexport default class IDAStar{\n\tconstructor(options){\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.biDirectional = options.biDirectional;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t\t// this.heuristic = heuristics[\"euclidean\"];\n\t\tthis.timeLimit = 100;\n\t}\n\n\tgetDistanceFromRootNode(rootNode, neighbour){\n\t\tif((Math.abs(rootNode.x-neighbour.x)+Math.abs(rootNode.y-neighbour.y))===1){\n\t\t\treturn 1;\n\t\t}\n\t\treturn Math.SQRT2;\n\t}\n\n\ttimeUp(){\n\t\treturn (Math.abs(this.startTime - new Date())>this.timeLimit);\n\t}\n\n\tfindPath(grid){\n\t\tthis.grid = grid;\n\t\tlet uppperBound = this.heuristic(grid.startPoint, grid.endPoint),\n\t\t\treturnedInstance;\n\n\t\tgrid.startNode = grid.getNodeAtXY(grid.startPoint.x, grid.startPoint.y);\n\t\tgrid.endNode = grid.getNodeAtXY(grid.endPoint.x, grid.endPoint.y);\n\n\t\tthis.startTime = new Date();\n\t\tlet path = [ grid.startNode ];\n\n\t\twhile(true){\n\t\t\treturnedInstance = this.search(path, 0, uppperBound);\n\n\t\t\tif(typeof(returnedInstance) === \"number\"){\n\t\t\t\tconsole.info(\"bound Increased to\", returnedInstance);\n\t\t\t\tuppperBound = returnedInstance;\n\t\t\t} else if(returnedInstance === \"FOUND\"){\n\t\t\t\treturn path;\n\t\t\t} else {\n\t\t\t\treturn returnedInstance;\n\t\t\t}\n\t\t}\n\t}\n\n\tsearch(path, rootGVal, upperBound){\n\t\tlet rootNode = path.peekTop();\n\t\tif(this.timeUp()) {\n\t\t\tconsole.info(\"time exceeded\");\n\t\t\treturn [];\n\t\t}\n\n\t\tif(rootNode === this.grid.endNode){\n\t\t\tconsole.info(\"found\");\n\t\t\treturn \"FOUND\";\n\t\t}\n\n\t\tlet fVal = rootGVal + this.heuristic(rootNode, this.grid.endNode);\n\t\tif(fVal > upperBound) {\n\t\t\trootNode.explored = true;\n\t\t\treturn fVal;\n\t\t}\n\n\t\tif(this.markCurrentProcessingNode) rootNode.currentNode = true;\n\t\trootNode.visited = true;\n\n\t\tlet min = Infinity,\n\t\t\tneighbourGVal,\n\t\t\treturnedInstance,\n\t\t\tneighbour,\n\t\t\tneighbours = this.grid.getNeighbours(rootNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\n\t\twhile(neighbours.length){\n\t\t\tneighbour = neighbours.shift();\n\t\t\tif(!path.includes(neighbour)){\n\t\t\t\tpath.push(neighbour);\n\t\t\t\tneighbourGVal = rootGVal+this.getDistanceFromRootNode(rootNode, neighbour);\n\n\t\t\t\treturnedInstance = this.search(path, neighbourGVal, upperBound);\n\n\t\t\t\tif((typeof(returnedInstance) === \"number\") && (returnedInstance < min)){\n\t\t\t\t\tmin = returnedInstance;\n\t\t\t\t} else if(returnedInstance === \"FOUND\"){\n\t\t\t\t\treturn returnedInstance;\n\t\t\t\t}\n\t\t\t\tpath.pop(neighbour);\n\t\t\t}\n\t\t}\n\n\t\trootNode.visited = false;\n\t\treturn min;\n\t}\n}\n","import IDAStar from './IDAStar';\n\nexport default class IDDFS extends IDAStar{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.heuristic = () => 0;\n\t}\n}\n","import Heap from 'heap';\nimport backTrace from '../utils/BackTrace';\nimport heuristics from '../utils/Heuristics';\n\nexport default class JumpPointSearch{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t\tthis.heuristic = heuristics[options.heuristic];\n\t}\n\n\tgetNeighboursBasedOnOptions(currentProcessingNode){\n\t\tlet parent = currentProcessingNode.parent,\n\t\t\tabs = Math.abs,\n\t\t\tmax = Math.max,\n\t\t\tparentX,\n\t\t\tparentY,\n\t\t\txNormalizeDirection,\n\t\t\tyNormalizeDirection,\n\t\t\tx = currentProcessingNode.x,\n\t\t\ty = currentProcessingNode.y,\n\t\t\tneighbours = [];\n\t\tif (parent){\n\t\t\tparentX = parent.x;\n\t\t\tparentY = parent.y;\n\t\t\txNormalizeDirection = (x -parentX)/(max(abs(x -parentX), 1));\n\t\t\tyNormalizeDirection = (y -parentY)/(max(abs(y - parent.y), 1));\n\n\t\t\tif (xNormalizeDirection !== 0){\n\t\t\t\tif (!this.grid.isXYWallElement(x, y-1)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x, y-1));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x, y+1)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x, y+1));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x+xNormalizeDirection, y)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x+xNormalizeDirection, y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (yNormalizeDirection !== 0){\n\t\t\t\tif (!this.grid.isXYWallElement(x-1, y)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x-1, y));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x+1, y)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x+1, y));\n\t\t\t\t}\n\t\t\t\tif (!this.grid.isXYWallElement(x, y+yNormalizeDirection)){\n\t\t\t\t\tneighbours.push(this.grid.getNodeAtXY(x, y+yNormalizeDirection));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tneighbours = this.grid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\t\t}\n\t\treturn neighbours;\n\t}\n\n\tgetJumpPoints(currentProcessingNode, parent){\n\t\tlet x = currentProcessingNode.x,\n\t\t\ty = currentProcessingNode.y,\n\t\t\tparentX = parent.x,\n\t\t\tparentY = parent.y,\n\t\t\txDifference = currentProcessingNode.x - parent.x,\n\t\t\tyDifference = currentProcessingNode.y - parent.y;\n\t\tif (this.grid.isXYWallElement(x, y)){\n\t\t\treturn null;\n\t\t}\n\t\tif(this.markCurrentProcessingNode) currentProcessingNode.processed = true;\n\n\t\tif (currentProcessingNode === this.grid.endNode){\n\t\t\treturn currentProcessingNode;\n\t\t}\n\n\t\tif (xDifference !== 0){\n\t\t\tif ((!this.grid.isXYWallElement(x, y-1) && this.grid.isXYWallElement(parentX, y-1)) || (!this.grid.isXYWallElement(x, y+1) && this.grid.isXYWallElement(parentX, y+1))){\n\t\t\t\treturn currentProcessingNode;\n\t\t\t}\n\t\t} else if (yDifference !== 0){\n\t\t\tif ((!this.grid.isXYWallElement(x-1, y) && this.grid.isXYWallElement(x-1, parentY)) || (!this.grid.isXYWallElement(x+1, y) && this.grid.isXYWallElement(x+1, parentY))){\n\t\t\t\treturn currentProcessingNode;\n\t\t\t}\n\t\t\tif (this.getJumpPoints(this.grid.getNodeAtXY(x+1, y), currentProcessingNode) || this.getJumpPoints(this.grid.getNodeAtXY(x-1, y), currentProcessingNode)){\n\t\t\t\treturn currentProcessingNode;\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.log('only vertical and horizontal movements allowed');\n\t\t}\n\n\t\tif (x+xDifference>=0 && x+xDifference<this.grid.columns && y+yDifference>=0 && y+yDifference<this.grid.rows){\n\t\t\treturn this.getJumpPoints(this.grid.getNodeAtXY(x+xDifference, y+yDifference), currentProcessingNode);\n\t\t}\n\t}\n\n\tsuccessor(currentProcessingNode){\n\n\t\tlet neighbours = [],\n\t\t\tjumpPointNode,\n\t\t\tneighbour,\n\t\t\tjumpPointDistanceFromStart;\n\t\tneighbours = this.getNeighboursBasedOnOptions(currentProcessingNode);\n\n\t\twhile(neighbours.length){\n\t\t\tneighbour = neighbours.shift();\n\t\t\tjumpPointNode = this.getJumpPoints(neighbour, currentProcessingNode);\n\t\t\tif (jumpPointNode){\n\t\t\t\tif (jumpPointNode.visited){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tjumpPointDistanceFromStart = currentProcessingNode.g + heuristics['octile'](jumpPointNode, currentProcessingNode);\n\t\t\t\tif(!jumpPointNode.addedToHeap || jumpPointDistanceFromStart<jumpPointNode.g){\n\t\t\t\t\tjumpPointNode.g = jumpPointDistanceFromStart;\n\t\t\t\t\tjumpPointNode.h = this.heuristic(this.grid.endNode, jumpPointNode);\n\t\t\t\t\tjumpPointNode.f = jumpPointNode.g+jumpPointNode.h;\n\t\t\t\t\tjumpPointNode.parent = currentProcessingNode;\n\n\t\t\t\t\tif (!jumpPointNode.addedToHeap){\n\t\t\t\t\t\tthis.minHeap.insert(jumpPointNode);\n\t\t\t\t\t\tjumpPointNode.addedToHeap = true;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tthis.minHeap.updateItem(jumpPointNode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfindPath(grid){\n\t\tthis.grid = grid;\n\t\tlet minHeap = new Heap((node1, node2) => node1.f-node2.f),\n\t\t\tcurrentProcessingNode;\n\t\tthis.minHeap = minHeap;\n\n\t\tthis.grid.startNode = this.grid.getNodeAtXY(this.grid.startPoint.x, this.grid.startPoint.y);\n\t\tthis.grid.endNode = this.grid.getNodeAtXY(this.grid.endPoint.x, this.grid.endPoint.y);\n\t\tthis.grid.startNode.g = 0;\n\t\tthis.grid.startNode.f = 0;\n\t\tthis.minHeap.insert(this.grid.startNode);\n\t\tthis.grid.startNode.addedToHeap = true;\n\n\t\twhile(!this.minHeap.empty()){\n\n\t\t\tcurrentProcessingNode = this.minHeap.pop();\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.processed = true;\n\t\t\tcurrentProcessingNode.visited = true;\n\n\t\t\tif (currentProcessingNode === this.grid.endNode){\n\t\t\t\tlet jumpPoints = backTrace.backTrace(this.grid.endNode, this.grid.startNode);\n\t\t\t\tlet path = backTrace.expandPath(this.grid, jumpPoints, this.grid.startNode);\n\t\t\t\tconsole.log(path);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t\tthis.successor(currentProcessingNode);\n\t\t}\n\t\treturn [];\n\t}\n}\n","import Denque from 'denque';\nimport backTrace from '../utils/BackTrace';\n\nexport default class MultiBFS{\n\tconstructor(options){\n\t\tconsole.log(options);\n\t\tthis.allowDiagonal = options.allowDiagonal;\n\t\tthis.doNotCrossCornersBetweenObstacles = options.doNotCrossCornersBetweenObstacles;\n\t\tthis.markCurrentProcessingNode = options.markCurrentProcessingNode;\n\t}\n\n\tfindPath(multiEPGrid){\n\t\tlet startPoint = multiEPGrid.startPoint,\n\t\t\tstartNode = multiEPGrid.getNodeAtXY(startPoint.x, startPoint.y),\n\t\t\tqueue = new Denque([startNode]),\n\t\t\tcurrentProcessingNode,\n\t\t\tneighbours,\n\t\t\tpath = [];\n\n\t\tstartNode.addedToQueue = true;\n\t\twhile(!queue.isEmpty()){\n\t\t\tcurrentProcessingNode = queue.shift();\n\n\t\t\tif(this.markCurrentProcessingNode) currentProcessingNode.currentNode = true;\n\n\t\t\tif(multiEPGrid.isXYEndPoint(currentProcessingNode.x, currentProcessingNode.y)){\n\t\t\t\tpath = path.concat(backTrace.backTrace(currentProcessingNode, startNode));\n\t\t\t\tstartNode = currentProcessingNode;\n\t\t\t\tmultiEPGrid.removeEndPoint(currentProcessingNode);\n\t\t\t\tconsole.log(path, multiEPGrid.endPoints);\n\t\t\t\tqueue.clear();\n\t\t\t\tmultiEPGrid = multiEPGrid.clone();\n\t\t\t\tif(!multiEPGrid.endPoints.length) return path;\n\t\t\t}\n\n\t\t\tneighbours = multiEPGrid.getNeighbours(currentProcessingNode, this.allowDiagonal, this.doNotCrossCornersBetweenObstacles);\n\t\t\tneighbours.forEach(neighbour => {\n\t\t\t\tif(neighbour.addedToQueue || neighbour.visited) return;\n\n\t\t\t\tneighbour.addedToQueue = true;\n\t\t\t\tqueue.push(neighbour);\n\t\t\t\tneighbour.parent = currentProcessingNode;\n\t\t\t});\n\n\t\t\tcurrentProcessingNode.visited = true;\n\t\t}\n\n\t\treturn path;\n\t}\n}\n","class GraphNode{\n\tconstructor(options){\n\t\tthis.x = options.x;\n\t\tthis.y = options.y;\n\t}\n}\n\nexport default GraphNode;\n","import GraphNode from './GraphNode';\n\nclass Grid{\n\tconstructor(options){\n\t\tthis.rows = options.rows;\n\t\tthis.columns = options.columns;\n\t\tthis.startPoint = options.startPoint;\n\t\tthis.endPoint = options.endPoint;\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tthis[y] = new Array(this.columns);\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tthis[y][x] = new GraphNode({x, y});\n\t\t\t}\n\t\t}\n\t}\n\n\tisXYWallElement(x, y){\n\t\tif(x<0 || x>=this.columns || y<0 || y>=this.rows) return true;\n\t\treturn (this[y][x].isWall?true:false);\n\t}\n\n\tmakeXYWall(x, y){\n\t\tthis[y][x].isWall = true;\n\t}\n\n\tdestroyWallAtXY(x, y){\n\t\tthis[y][x].isWall = false;\n\t}\n\n\tisXYStartPoint(x, y){\n\t\treturn ((this.startPoint.x === x )&&(this.startPoint.y === y));\n\t}\n\n\tisXYEndPoint(x, y){\n\t\treturn ((this.endPoint.x === x )&&(this.endPoint.y === y));\n\t}\n\n\tgetNodeAtXY(x, y){\n\t\treturn this[y][x];\n\t}\n\n\tclone(){\n\t\tlet grid = new Grid(this);\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tif(this.isXYWallElement(x, y)) grid.makeXYWall(x, y);\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\n\t/*\n\t\t|_ _|_a_|_ _| |_p_|_ _|_q_| \n\t\t|_d_|_*_|_b_| |_ _|_*_|_ _|\n\t\t|_ _|_c_|_ _| |_s_|_ _|_r_|\n\t */\n\tgetNeighbours(node, allowDiagonal, doNotCrossCornersBetweenObstacles){\n\t\tlet neighbours = [];\n\t\tconst {x, y} = node;\n\t\tlet a, b, c, d;\n\n\t\t// b\n\t\tif(!this.isXYWallElement(x+1, y)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x+1, y));\n\t\t\tb = true;\n\t\t}\n\t\t// c\n\t\tif(!this.isXYWallElement(x, y+1)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x, y+1));\n\t\t\tc = true;\n\t\t}\n\t\t// d\n\t\tif(!this.isXYWallElement(x-1, y)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x-1, y));\n\t\t\td = true;\n\t\t}\n\t\t// a\n\t\tif(!this.isXYWallElement(x, y-1)) {\n\t\t\tneighbours.push(this.getNodeAtXY(x, y-1));\n\t\t\ta = true;\n\t\t}\n\n\t\tif(allowDiagonal){\n\t\t\tif(doNotCrossCornersBetweenObstacles){\n\t\t\t\t//p\n\t\t\t\tif( (a || d) & !this.isXYWallElement(x-1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y-1));\n\t\t\t\t}\n\t\t\t\t//q\n\t\t\t\tif( (a || b) & !this.isXYWallElement(x+1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y-1));\n\t\t\t\t}\n\t\t\t\t//r\n\t\t\t\tif( (b || c) & !this.isXYWallElement(x+1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y+1));\n\t\t\t\t}\n\t\t\t\t//s\n\t\t\t\tif( (c || d) & !this.isXYWallElement(x-1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y+1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//p\n\t\t\t\tif(!this.isXYWallElement(x-1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y-1));\n\t\t\t\t}\n\t\t\t\t//q\n\t\t\t\tif(!this.isXYWallElement(x+1, y-1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y-1));\n\t\t\t\t}\n\t\t\t\t//r\n\t\t\t\tif(!this.isXYWallElement(x+1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x+1, y+1));\n\t\t\t\t}\n\t\t\t\t//s\n\t\t\t\tif(!this.isXYWallElement(x-1, y+1)) {\n\t\t\t\t\tneighbours.push(this.getNodeAtXY(x-1, y+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn neighbours;\n\t}\n}\n\nexport default Grid;\n","import Grid from './Grid';\n\nclass MultiEPGrid extends Grid{\n\tconstructor(options){\n\t\tsuper(options);\n\n\t\tthis.endPoints = options.endPoints;\n\t}\n\n\tisXYEndPoint(x, y){\n\t\treturn (this.endPoints.some(ep => (ep.x===x)&&(ep.y===y)));\n\t}\n\n\tshiftEndPoint(from, to){\n\t\tlet i = this.endPoints.findIndex(ep => (ep.x===from.x)&&(ep.y===from.y));\n\t\tif(i!=-1){\n\t\t\tthis.endPoints[i] = to;\n\t\t}\n\t}\n\n\tremoveEndPoint(node){\n\t\tthis.endPoints = this.endPoints.filter(ep => !((ep.x===node.x)&&(ep.y===node.y)));\n\t}\n\n\tclone(){\n\t\tlet grid = new MultiEPGrid(this);\n\n\t\tfor(let y=0; y<this.rows; y++){\n\t\t\tfor(let x=0; x<this.columns; x++){\n\t\t\t\tif(this.isXYWallElement(x, y)) grid.makeXYWall(x, y);\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n}\n\nexport default MultiEPGrid;\n","import Grid from './core/Grid';\nimport MultiEPGrid from './core/MultiEPGrid';\nimport GraphNode from './core/GraphNode';\nimport BreadthFirstSearch from './algorithms/BreadthFirstSearch';\nimport AStar from './algorithms/AStar';\nimport Dijkshtra from './algorithms/Dijkshtra';\nimport BestFirstSearch from './algorithms/BestFirstSearch';\nimport IDAStar from './algorithms/IDAStar';\nimport IDDFS from './algorithms/IDDFS';\nimport JumpPointSearch from './algorithms/JumpPointSearch';\nimport MultiBFS from './algorithms/MultiBFS';\n\nexport default {\n\tGrid,\n\tMultiEPGrid,\n\tGraphNode,\n\tBreadthFirstSearch,\n\tAStar,\n\tDijkshtra,\n\tBestFirstSearch,\n\tIDAStar,\n\tIDDFS,\n\tJumpPointSearch,\n\tMultiBFS\n};\n","class BackTrace{\n\tbackTrace(node, startNode){\n\t\tlet path = [];\n\t\twhile(node !== startNode){\n\t\t\tpath.push(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\tpath.reverse();\n\t\treturn path;\n\t}\n\n\tbiBackTrace(node1, startNode, node2, endNode){\n\t\tlet path1 = this.backTrace(node1, startNode),\n\t\t\tpath2 = this.backTrace(node2, endNode);\n\t\tpath2.reverse();\n\t\tlet path = path1.concat(path2);\n\t\treturn path;\n\t}\n\n\tgetInterpolation(grid, firstNode, secondNode){\n\t\tlet x1 = firstNode.x,\n\t\t\ty1 = firstNode.y,\n\t\t\tx2 = secondNode.x,\n\t\t\ty2 = secondNode.y,\n\t\t\txDifference = Math.abs(x2 - x1),\n\t\t\tyDifference = Math.abs(y2 - y1),\n\t\t\txDirection = (x2>x1) ? 1 : -1,\n\t\t\tyDirection = (y2>y1) ? 1 : -1,\n\t\t\tinterpolatedValues = [],\n\t\t\tintermidateDistance;\n\n\t\tintermidateDistance = xDifference - yDifference;\n\n\t\twhile((x1 !== x2) || (y1 !== y2)){\n\t\t\tinterpolatedValues.push(firstNode);\n\t\t\tif (2 *intermidateDistance > -yDifference){\n\t\t\t\tintermidateDistance = intermidateDistance - yDifference;\n\t\t\t\tx1 = x1 +xDirection;\n\t\t\t} else if (2*intermidateDistance < xDifference){\n\t\t\t\tintermidateDistance = intermidateDistance +xDifference;\n\t\t\t\ty1 = y1 +yDirection;\n\t\t\t}\n\t\t\tfirstNode = grid.getNodeAtXY(x1, y1);\n\t\t}\n\t\treturn interpolatedValues;\n\t}\n\n\texpandPath(grid, path, startNode){\n\t\tlet expandedPath =[],\n\t\t\tfirstNode,\n\t\t\tsecondNode,\n\t\t\tinterpolatedValues = [];\n\n\t\tfirstNode = startNode;\n\t\twhile(path.length){\n\t\t\tsecondNode = path.shift();\n\t\t\tinterpolatedValues = this.getInterpolation(grid, firstNode, secondNode);\n\t\t\twhile(interpolatedValues.length){\n\t\t\t\texpandedPath.push(interpolatedValues.shift());\n\t\t\t}\n\t\t\tfirstNode = secondNode;\n\t\t}\n\n\t\texpandedPath.push(secondNode);\n\t\texpandedPath.shift();\n\t\treturn expandedPath;\n\t}\n}\n\nexport default new BackTrace();\n","let abs = Math.abs,\n\tsqrt = Math.sqrt,\n\tmax = Math.max,\n\tmin = Math.min;\n\nclass Heuristic{\n\n\tmanhattan(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*(dx+dy);\n\t}\n\n\teuclidean(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*sqrt(dx*dx + dy*dy);\n\t}\n\n\toctile(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*(max(dx, dy)+(sqrt(2)-1)*min(dx, dy));\n\t}\n\n\tchebyshev(nodeA, nodeB, weight=1){\n\t\tlet dx = abs(nodeA.x-nodeB.x);\n\t\tlet dy = abs(nodeA.y-nodeB.y);\n\t\treturn weight*(max(dx, dy));\n\t}\n}\n\nexport default new Heuristic();\n"],"sourceRoot":""}